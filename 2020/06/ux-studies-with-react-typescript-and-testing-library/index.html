<!DOCTYPE html>
<html lang=en>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="Studying and applying UX using React, Typescript, Testing Library">
  <meta name="keywords" content="javascript,typescript,web_development">
  <meta property="og:type" content="article">
  <meta property="og:title" content="UX Studies with React, Typescript, and Testing Library">
  <meta property="og:description" content="Studying and applying UX using React, Typescript, Testing Library">
  <meta property="og:locale" content="en">
  <meta property="og:image" content="assets/cover.jpg">
  <meta property="og:updated_time" content="2020-06-21T00:00:00.000Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="UX Studies with React, Typescript, and Testing Library">
  <meta name="twitter:description" content="Studying and applying UX using React, Typescript, Testing Library">
  <meta name="twitter:image" content="assets/cover.jpg">

  <title>UX Studies with React, Typescript, and Testing Library</title>
  <link rel="stylesheet" type="text/css" href="../../../stylesheets/main.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css"
    integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/styles/night-owl.min.css">
</head>

<body>
  <div class="content index width mx-auto px2 my4">
    <div id="header-post">
      <a id="menu-icon" href="../../../index.html">
        <i class="fas fa-long-arrow-alt-left"></i>
        Home
      </a>
    </div>
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
      <header>
        <h1 class="posttitle">UX Studies with React, Typescript, and Testing Library</h1>
        <div class="meta">
          <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span itemprop="name">TK</span>
          </span>

          <div class="postdate">
            <time datetime="2020-06-21T00:00:00.000Z" itemprop="datePublished">2020-06-21</time>
          </div>

          <div class="article-tag">
            <i class=b fa-tag"></i>
            <a class="tag-link" href="../../../tags/javascript.html">javascript</a>
            <a class="tag-link" href="../../../tags/typescript.html">typescript</a>
            <a class="tag-link" href="../../../tags/web_development.html">web_development</a>

          </div>
        </div>
      </header>

      <div class="figure">
        <img src="assets/cover.jpg" alt="Matrix">
        <span class="figcaption">
          Photo by <a href="https://unsplash.com/@mojaghrout" target="_blank">Moujib Aghrout</a>
        </span>
      </div>

      <hr />

      <p>I'm always willing to learn more and more. As a software engineer, the thirst for knowledge increased a lot. We
        have a lot of things to learn daily. But I wanted to master the foundation. To make me a better developer, I
        wanted to understand more about how to create great product experiences.</p>
      <p>This post is my attempt to illustrate a Proof of Concept (PoC) I built to try some ideas as experiments.</p>
      <p>I had some topics in mind to build this. It needs to strive for:</p>
      <ul>
        <li>High-quality software</li>
        <li>User Experience</li>
      </ul>
      <p>When I say high-quality software, it can have so many different meanings. But I want to focus on three parts:
      </p>
      <ul>
        <li>Clean Code: Strive to write human-readable code, that is easy to read and simple to maintain. Separate
          responsibility for functions and components.</li>
        <li>Good test coverage: It's actually not about coverage. It's about tests that cover important parts of
          components' behavior without knowing too much about implementation details.</li>
        <li>Consistent state management: I want to build with software that enables the app to have consistent data.
          Predictability is important.</li>
      </ul>
      <p>And user experience is the main focus of this PoC. The software and techniques are the foundation to enable
        good experience for users.</p>
      <p>To make the state consistent, I wanted a type system. So I chose Typescript. This was the first time I'm using
        Typescript with React. This project also allowed me to build custom hooks and test it properly.</p>
      <h2 id="settinguptheproject">Setting up the project</h2>
      <p>I came across this library called <a href="https://github.com/jaredpalmer/tsdx">tsdx</a> that sets up all the
        Typescript configuration for you. It's mainly used to build packages. As this was a simple side project, I
        didn't mind giving it a try.</p>
      <p>After installing it, I chose the react template and I was ready to code. But before the fun part, I wanted to
        set up the test configuration too. <a href="https://github.com/testing-library/react-testing-library">React
          Testing Library</a> as the main library together with <a
          href="https://github.com/testing-library/jest-dom">jest-dom</a> to provide some awesome custom methods (I
        really like the <code>toBeInTheDocument</code> matcher).</p>
      <p>With all installed, I overwrote the jest config by adding a new <code>jest.config.js</code>:</p>
      <pre><code class="typescript language-typescript">module.exports = {
  verbose: true,
  setupFilesAfterEnv: ["./setupTests.ts"],
};
</code></pre>
      <p>And a <code>setupTests.ts</code> to import everything I need.</p>
      <pre><code class="typescript language-typescript">import "@testing-library/jest-dom";
</code></pre>
      <p>In this case, I just had the <code>jest-dom</code> library to import. This way, I don't need to import this
        package in my test files. Now it works out of the box.</p>
      <p>To test this installation and configuration, I built a simple component:</p>
      <pre><code class="typescript language-typescript">export const Thing = () =&gt; &lt;h1&gt;I'm TK&lt;/h1&gt;;
</code></pre>
      <p>In my test, I wanted to render it and see if it was in the DOM.</p>
      <pre><code class="typescript language-typescript">import React from 'react';
import { render } from '@testing-library/react';
import { Thing } from '../index';

describe('Thing', () =&gt; {
  it('renders the correct text in the document', () =&gt; {
    const { getByText } = render(&lt;Thing /&gt;);

    expect(getByText("I'm TK")).toBeInTheDocument();
  });
});
</code></pre>
      <p>And we are ready for the next step now!</p>
      <h2 id="configuringroutes">Configuring routes</h2>
      <p>Here I'll have only two routes for now. The home page and the search page - even though I'll do nothing about
        the home page.</p>
      <p>For this project, I'm using the <code>react-router-dom</code> library to handle all things router. It's simple,
        easy, and fun to work with.</p>
      <p>After installing it, I added the router components in the <code>app.typescript</code>.</p>
      <pre><code class="typescript language-typescript">import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';

export const App = () =&gt; (
  &lt;Router&gt;
    &lt;Switch&gt;
      &lt;Route path="/search"&gt;
        &lt;h1&gt;It's the search!&lt;/h1&gt;
      &lt;/Route&gt;
      &lt;Route path="/"&gt;
        &lt;h1&gt;It's Home&lt;/h1&gt;
      &lt;/Route&gt;
    &lt;/Switch&gt;
  &lt;/Router&gt;
);
</code></pre>
      <p>Now if we enter the <code>localhost:1234</code>, we see the title <code>It's Home</code>. Go to the
        <code>localhost:1234/search</code>, we see the text <code>It's the search!</code>.</p>
      <p>Before we continue to start implementing our search page, I wanted to build a simple menu to switch between
        home and search pages without manipulating the URL. For this project, I'm using <a
          href="https://material-ui.com/">Material UI</a> to build the UI foundation.</p>
      <p>For now, we are just installing the <code>@material-ui/core</code>.</p>
      <p>To build the menu, we have the button to open the menu options. In this case "home" and "search" options. But
        to build a better component abstraction, I prefer to hide the content (link and label) for the menu items and
        make the <code>Menu</code> component receive this data as a prop. This way, the menu doesn't know about the
        items, it will just iterate through the items list and render them.</p>
      <p>It looks like this:</p>
      <pre><code class="typescript language-typescript">import React, { Fragment, useState, MouseEvent } from 'react';
import { Link } from 'react-router-dom';
import Button from '@material-ui/core/Button';
import MuiMenu from '@material-ui/core/Menu';
import MuiMenuItem from '@material-ui/core/MenuItem';

import { MenuItem } from '../../types/MenuItem';

type MenuPropsType = { menuItems: MenuItem[] };

export const Menu = ({ menuItems }: MenuPropsType) =&gt; {
  const [anchorEl, setAnchorEl] = useState&lt;null | HTMLElement&gt;(null);

  const handleClick = (event: MouseEvent&lt;HTMLButtonElement&gt;): void =&gt; {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = (): void =&gt; {
    setAnchorEl(null);
  };

  return (
    &lt;Fragment&gt;
      &lt;Button aria-controls="menu" aria-haspopup="true" onClick={handleClick}&gt;
        Open Menu
      &lt;/Button&gt;
      &lt;MuiMenu
        id="simple-menu"
        anchorEl={anchorEl}
        keepMounted
        open={Boolean(anchorEl)}
        onClose={handleClose}
      &gt;
        {menuItems.map((item: MenuItem) =&gt; (
          &lt;Link to={item.linkTo} onClick={handleClose} key={item.key}&gt;
            &lt;MuiMenuItem&gt;{item.label}&lt;/MuiMenuItem&gt;
          &lt;/Link&gt;
        ))}
      &lt;/MuiMenu&gt;
    &lt;/Fragment&gt;
  );
};

export default Menu;
</code></pre>
      <p>Don't panic! I know it is a huge block of code, but it is pretty simple. the <code>Fragment</code> wrap the
        <code>Button</code> and <code>MuiMenu</code> (<code>Mui</code> stands for Material UI. I needed to rename the
        component because the component I'm building is also called menu).</p>
      <p>It receives the <code>menuItems</code> as a prop and maps through it to build the menu item wrapped by the
        <code>Link</code> component. Link is a component from react-router to link to a given URL.</p>
      <p>The menu behavior is also simple: we bind the <code>handleClick</code> function to the button's
        <code>onClick</code>. That way, we can change <code>anchorEl</code> when the button is triggered (or clicked if
        you prefer). The <code>anchorEl</code> is just a component state that represents the Mui menu element to open
        the menu switch. So it will open the menu items to let the user chooses one of those.</p>
      <p>Now, how do we use this component?</p>
      <pre><code class="typescript language-typescript">import { Menu } from './components/Menu';
import { MenuItem } from './types/MenuItem';

const menuItems: MenuItem[] = [
  {
    linkTo: '/',
    label: 'Home',
    key: 'link-to-home',
  },
  {
    linkTo: '/search',
    label: 'Search',
    key: 'link-to-search',
  },
];

&lt;Menu menuItems={menuItems} /&gt;
</code></pre>
      <p>The <code>menuItems</code> is a list of objects. The object has the correct contract expected by the
        <code>Menu</code> component. The type <code>MenuItem</code> ensures that the contract is correct. It is just a
        Typescript <code>type</code>:</p>
      <pre><code class="typescript language-typescript">export type MenuItem = {
  linkTo: string;
  label: string;
  key: string;
};
</code></pre>
      <h2 id="search">Search</h2>
      <p>Now we are ready to build the search page with all the products and a great experience. But before building the
        list of products, I wanted to create a fetch function to handle the request for products. As I don't have an API
        of products yet, I can just mock the fetch request.</p>
      <p>At first, I just built the fetching with <code>useEffect</code> in the <code>Search</code> component. The idea
        would look like this:</p>
      <pre><code class="typescript language-typescript">import React, { useState, useEffect } from 'react';
import { getProducts } from 'api';

export const Search = () =&gt; {
  const [products, setProducts] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [hasError, setHasError] = useState(false);

  useEffect(() =&gt; {
    const fetchProducts = async () =&gt; {
      try {
        setIsLoading(true);

        const fetchedProducts = await getProducts();

        setIsLoading(false);
        setProducts(fetchedProducts);
      } catch (error) {
        setIsLoading(false);
        setHasError(true);
      }
    };

    fetchProducts();
  }, []);
};
</code></pre>
      <p>I have:</p>
      <ul>
        <li><code>products</code> initialized as an empty array</li>
        <li><code>isLoading</code> initialized as false</li>
        <li><code>hasError</code> initialized as false</li>
        <li>The <code>fetchProducts</code> is an async function that calls <code>getProducts</code> from the
          <code>api</code> module. As we don't have a proper API for products yet, this <code>getProducts</code> would
          return a mock data.</li>
        <li>When the <code>fetchProducts</code> is executed, we set the <code>isLoading</code> to true, fetch the
          products, and then set the <code>isLoading</code> to false, because the fetching finished, and the set the
          fetched products into <code>products</code> to be used in the component.</li>
        <li>If it gets any error in the fetching, we catch them, set the <code>isLoading</code> to false, and the
          <code>hasError</code> to true. In this context, the component will know that we had an error while fetching
          and can handle this case.</li>
        <li>Everything is encapsulated into a <code>useEffect</code> because we are doing a side effect here.</li>
      </ul>
      <p>To handle all the state logic (when to update each part for the specific context), we can extract it to a
        simple reducer.</p>
      <pre><code class="typescript language-typescript">import { State, FetchActionType, FetchAction } from './types';

export const fetchReducer = (state: State, action: FetchAction): State =&gt; {
  switch (action.type) {
    case FetchActionType.FETCH_INIT:
      return {
        ...state,
        isLoading: true,
        hasError: false,
      };
    case FetchActionType.FETCH_SUCCESS:
      return {
        ...state,
        hasError: false,
        isLoading: false,
        data: action.payload,
      };
    case FetchActionType.FETCH_ERROR:
      return {
        ...state,
        hasError: true,
        isLoading: false,
      };
    default:
      return state;
  }
};
</code></pre>
      <p>The idea here is to separate each action type and handle each state update. So the <code>fetchReducer</code>
        will receive the state and the action and it will return a new state. This part is interesting because it gets
        the current state and then returns a new state, but we keep the state contract by using the <code>State</code>
        type.</p>
      <p>And for each action type, we will update the state the right way.</p>
      <ul>
        <li><code>FETCH_INIT</code>: <code>isLoading</code> is true and <code>hasError</code> is false.</li>
        <li><code>FETCH_SUCCESS</code>: <code>hasError</code> is false, <code>isLoading</code> is false, and the data
          (products) is updated.</li>
        <li><code>FETCH_ERROR</code>: <code>hasError</code> is true and <code>isLoading</code> is false.</li>
      </ul>
      <p>In case it doesn't match any action type, just return the current state.</p>
      <p>The <code>FetchActionType</code> is a simple Typescript enum:</p>
      <pre><code class="typescript language-typescript">export enum FetchActionType {
  FETCH_INIT = 'FETCH_INIT',
  FETCH_SUCCESS = 'FETCH_SUCCESS',
  FETCH_ERROR = 'FETCH_ERROR',
}
</code></pre>
      <p>And the <code>State</code> is just a simple type:</p>
      <pre><code class="typescript language-typescript">export type ProductType = {
  name: string;
  price: number;
  imageUrl: string;
  description: string;
  isShippingFree: boolean;
  discount: number;
};

export type Data = ProductType[];

export type State = {
  isLoading: boolean;
  hasError: boolean;
  data: Data;
};
</code></pre>
      <p>With this new reducer, now we can <code>useReducer</code> in our fetch. We pass the new reducer and the initial
        state to it:</p>
      <pre><code class="typescript language-typescript">const initialState: State = {
  isLoading: false,
  hasError: false,
  data: fakeData,
};

const [state, dispatch] = useReducer(fetchReducer, initialState);

useEffect(() =&gt; {
  const fetchAPI = async () =&gt; {
    dispatch({ type: FetchActionType.FETCH_INIT });

    try {
      const payload = await fetchProducts();

      dispatch({
        type: FetchActionType.FETCH_SUCCESS,
        payload,
      });
    } catch (error) {
      dispatch({ type: FetchActionType.FETCH_ERROR });
    }
  };

  fetchAPI();
}, []);
</code></pre>
      <p>The <code>initialState</code> has the same contract type. And we pass it to the <code>useReducer</code>
        together with the <code>fetchReducer</code> we just built. The <code>useReducer</code> provides the state and a
        function called <code>dispatch</code> to call actions to update our state.</p>
      <ul>
        <li>State fetching: dispatch <code>FETCH_INIT</code></li>
        <li>Finished fetch: dispatch <code>FETCH_SUCCESS</code> with the products payload</li>
        <li>Get an error while fetching: dispatch <code>FETCH_ERROR</code></li>
      </ul>
      <p>This abstraction got very big and can be very verbose in our component. We could extract it as a separate hook
        called <code>useProductFetchAPI</code>.</p>
      <pre><code class="typescript language-typescript">export const useProductFetchAPI = (): State =&gt; {
  const initialState: State = {
    isLoading: false,
    hasError: false,
    data: fakeData,
  };

  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() =&gt; {
    const fetchAPI = async () =&gt; {
      dispatch({ type: FetchActionType.FETCH_INIT });

      try {
        const payload = await fetchProducts();

        dispatch({
          type: FetchActionType.FETCH_SUCCESS,
          payload,
        });
      } catch (error) {
        dispatch({ type: FetchActionType.FETCH_ERROR });
      }
    };

    fetchAPI();
  }, []);

  return state;
};
</code></pre>
      <p>It is just a function that wraps our fetch operation. Now, in the <code>Search</code> component, we can import
        and call it.</p>
      <pre><code>export const Search = () =&gt; {
  const { isLoading, hasError, data }: State = useProductFetchAPI();
};
</code></pre>
      <p>We have all the API: <code>isLoading</code>, <code>hasError</code>, and <code>data</code> to use in our
        component. With this API, we can render a loading spinner or a skeleton based on the <code>isLoading</code>
        data. We can render an error message based on the <code>hasError</code> value. Or just render the list of
        products using the <code>data</code>.</p>
      <p>Before starting implementing our products list, I want to stop and add tests for our custom hook. We have two
        parts to test here: the reducer and the custom hook.</p>
      <p>The reducer is easier as it is just a pure function. It receives value, process, and returns a new value. No
        side-effect. Everything deterministic.</p>
      <p>To cover all the possibilities of this reducer, I created three contexts: <code>FETCH_INIT</code>,
        <code>FETCH_SUCCESS</code>, and <code>FETCH_ERROR</code> actions.</p>
      <p>Before implementing anything, I set up the initial data to work with.</p>
      <pre><code class="typescript language-typescript">const initialData: Data = [];
const initialState: State = {
  isLoading: false,
  hasError: false,
  data: initialData,
};
</code></pre>
      <p>Now I can pass this initial state for the reducer together with the specific action I want to cover. For this
        first test, I wanted to cover the <code>FETCH_INIT</code> action:</p>
      <pre><code class="typescript language-typescript">describe('when dispatch FETCH_INIT action', () =&gt; {
  it('returns the isLoading as true without any error', () =&gt; {
    const action: FetchAction = {
      type: FetchActionType.FETCH_INIT,
    };

    expect(fetchReducer(initialState, action)).toEqual({
      isLoading: true,
      hasError: false,
      data: initialData,
    });
  });
});
</code></pre>
      <p>It's pretty simple. It receives the initial state and the action, and we expect the proper return value: the
        new state with the <code>isLoading</code> as <code>true</code>.</p>
      <p>The <code>FETCH_ERROR</code> is pretty similar:</p>
      <pre><code class="typescript language-typescript">describe('when dispatch FETCH_ERROR action', () =&gt; {
  it('returns the isLoading as true without any error', () =&gt; {
    const action: FetchAction = {
      type: FetchActionType.FETCH_ERROR,
    };

    expect(fetchReducer(initialState, action)).toEqual({
      isLoading: false,
      hasError: true,
      data: [],
    });
  });
});
</code></pre>
      <p>But we pass a different action and expect the <code>hasError</code> to be <code>true</code>.</p>
      <p>The <code>FETCH_SUCCESS</code> is a bit complex as we just need to build a new state and add it to the payload
        attribute in the action.</p>
      <pre><code class="typescript language-typescript">describe('when dispatch FETCH_SUCCESS action', () =&gt; {
  it('returns the the API data', () =&gt; {
    const product: ProductType = {
      name: 'iPhone',
      price: 3500,
      imageUrl: 'image-url.png',
      description: 'Apple mobile phone',
      isShippingFree: true,
      discount: 0,
    };

    const action: FetchAction = {
      type: FetchActionType.FETCH_SUCCESS,
      payload: [product],
    };

    expect(fetchReducer(initialState, action)).toEqual({
      isLoading: false,
      hasError: false,
      data: [product],
    });
  });
});
</code></pre>
      <p>But nothing too complex here. The new data is there. A list of products. In this case, just one, the iPhone
        product.</p>
      <p>The second test will cover the custom hook we built. In these tests, I wrote three contexts: a time-out
        request, a failed network request, and a success request.</p>
      <p>Here, as I'm using <code>axios</code> to fetch data (when I have an API to fetch the data, I will use it
        properly), I'm using <code>axios-mock-adapter</code> to mock each context for our tests.</p>
      <p>The set up first: Initializing our data and set up an axios mock.</p>
      <pre><code class="typescript language-typescript">const mock: MockAdapter = new MockAdapter(axios);
const url: string = '/search';
const initialData: Data = [];
</code></pre>
      <p>We start implementing a test for the timeout request:</p>
      <pre><code class="typescript language-typescript">it('handles error on timed-out api request', async () =&gt; {
  mock.onGet(url).timeout();

  const { result, waitForNextUpdate } = renderHook(() =&gt;
    useProductFetchAPI(url, initialData)
  );

  await waitForNextUpdate();

  const { isLoading, hasError, data }: State = result.current;

  expect(isLoading).toEqual(false);
  expect(hasError).toEqual(true);
  expect(data).toEqual(initialData);
});
</code></pre>
      <p>We set up the mock to return a timeout. The test calls the <code>useProductFetchAPI</code>, wait for an update,
        and then we can get the state. The <code>isLoading</code> is false, the <code>data</code> is still the same (an
        empty list), and the <code>hasError</code> is now true as expected.</p>
      <p>The network request is pretty much the same behavior. The only difference is that the mock will have a network
        error instead of a timeout.</p>
      <pre><code class="typescript language-typescript">it('handles error on failed network api request', async () =&gt; {
  mock.onGet(url).networkError();

  const { result, waitForNextUpdate } = renderHook(() =&gt;
    useFetchAPI(url, initialData)
  );

  await waitForNextUpdate();

  const { isLoading, hasError, data }: State = result.current;

  expect(isLoading).toEqual(false);
  expect(hasError).toEqual(true);
  expect(data).toEqual(initialData);
});
</code></pre>
      <p>And for the success case, we need to create a product object to use it as a request-response data. We also
        expect the <code>data</code> to be a list of this product object. The <code>hasError</code> and the
        <code>isLoading</code> are false in this case.</p>
      <pre><code class="typescript language-typescript">it('gets and updates data from the api request', async () =&gt; {
  const product: ProductType = {
    name: 'iPhone',
    price: 3500,
    imageUrl: 'image-url.png',
    description: 'Apple mobile phone',
    isShippingFree: true,
    discount: 0,
  };

  const mockedResponseData: Data = [product];

  mock.onGet(url).reply(200, mockedResponseData);

  const { result, waitForNextUpdate } = renderHook(() =&gt;
    useFetchAPI(url, initialData)
  );

  await waitForNextUpdate();

  const { isLoading, hasError, data }: State = result.current;

  expect(isLoading).toEqual(false);
  expect(hasError).toEqual(false);
  expect(data).toEqual([product]);
});
</code></pre>
      <p>Great. We covered everything we needed for this custom hook and the reducer we created. Now we can focus on
        building the products list.</p>
      <h2 id="productslist">Products list</h2>
      <p>The idea of the products list is to list products that have some information: title, description, price,
        discount, and if it has free shipping. The final product card would look like this:</p>
      <p><img
          src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/08028cf1-3110-4f8a-98a2-148d0f040136/Screen_Shot_2020-06-06_at_15.52.17.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20200621%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20200621T150605Z&X-Amz-Expires=86400&X-Amz-Signature=946047ed293f4f8c4d57a02a1afe98b595a62550e632b8e8a014013123676097&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Screen_Shot_2020-06-06_at_15.52.17.png%22"
          alt="An example of a product card with the image, price, title, and description" />
      </p>
      <p>To build this card, I created the foundation for the product component:</p>
      <pre><code class="typescript language-typescript">const Product = () =&gt; (
  &lt;Box&gt;
    &lt;Image /&gt;
    &lt;TitleDescription/&gt;
    &lt;Price /&gt;
    &lt;Tag /&gt;
  &lt;/Box&gt;
);
</code></pre>
      <p>To build the product, we will need to build each component that is inside it.</p>
      <p>But before start building the product component, I want to show the <code>JSON</code> data that the fake API
        will return for us.</p>
      <pre><code class="typescript language-typescript">{
  imageUrl: 'a-url-for-tokyo-tower.png',
  name: 'Tokyo Tower',
  description: 'Some description here',
  price: 45,
  discount: 20,
  isShippingFree: true,
}
</code></pre>
      <p>This data is passed from the <code>Search</code> component to the <code>ProductList</code> component:</p>
      <pre><code class="typescript language-typescript">export const Search = () =&gt; {
  const { isLoading, hasError, data }: State = useProductFetchAPI();

  if (hasError) {
    return &lt;h2&gt;Error&lt;/h2&gt;;
  }

  return &lt;ProductList products={data} isLoading={isLoading} /&gt;;
};
</code></pre>
      <p>As I'm using Typescript, I can enforce the static types for the component props. In this case, I have the prop
        <code>products</code> and the <code>isLoading</code>.</p>
      <p>I built a <code>ProductListPropsType</code> type to handle the product list props.</p>
      <pre><code class="typescript language-typescript">type ProductListPropsType = {
  products: ProductType[];
  isLoading: boolean;
};
</code></pre>
      <p>And the <code>ProductType</code> is a simple type representing the product:</p>
      <pre><code class="typescript language-typescript">export type ProductType = {
  name: string;
  price: number;
  imageUrl: string;
  description: string;
  isShippingFree: boolean;
  discount: number;
};
</code></pre>
      <p>To build the ProductList, I'll use the <code>Grid</code> component from Material UI. First, we have a grid
        container and then, for each product, we will render a grid item.</p>
      <pre><code class="typescript language-typescript">export const ProductList = ({ products, isLoading }: ProductListPropsType) =&gt; (
  &lt;Grid container spacing={3}&gt;
    {products.map(product =&gt; (
      &lt;Grid
        item
        xs={6}
        md={3}
        key={`grid-${product.name}-${product.description}-${product.price}`}
      &gt;
        &lt;Product
          key={`product-${product.name}-${product.description}-${product.price}`}
          imageUrl={product.imageUrl}
          name={product.name}
          description={product.description}
          price={product.price}
          discount={product.discount}
          isShippingFree={product.isShippingFree}
          isLoading={isLoading}
        /&gt;
      &lt;/Grid&gt;
    ))}
  &lt;/Grid&gt;
);
</code></pre>
      <p>The <code>Grid</code> item will display 2 items per row for mobile as we use the value <code>6</code> for each
        column. And for the desktop version, it will render 4 items per row.</p>
      <p>We iterate through the <code>products</code> list and render the <code>Product</code> component passing all the
        data it will need.</p>
      <p>Now we can focus on building the <code>Product</code> component.</p>
      <p>Let's start with the easiest one: the <code>Tag</code>. We will pass three data to this component.
        <code>label</code>, <code>isVisible</code>, and <code>isLoading</code>. When it is not visible, we just return
        <code>null</code> to don't render it. If it is loading, we will render a <code>Skeleton</code> component from
        Material UI. But after loading it, we render the tag info with the <code>Free Shipping</code> label.</p>
      <pre><code class="typescript language-typescript">export const Tag = ({ label, isVisible, isLoading }: TagProps) =&gt; {
  if (!isVisible) return null;
  if (isLoading) {
    return (
      &lt;Skeleton width="110px" height="40px" data-testid="tag-skeleton-loader" /&gt;
    );
  }

  return (
    &lt;Box mt={1} data-testid="tag-label-wrapper"&gt;
      &lt;span style={tabStyle}&gt;{label}&lt;/span&gt;
    &lt;/Box&gt;
  );
};
</code></pre>
      <p>The <code>TagProps</code> is a simple type:</p>
      <pre><code class="typescript language-typescript">type TagProps = {
  label: string;
  isVisible: boolean;
  isLoading: boolean;
};
</code></pre>
      <p>I'm also using an object to style the <code>span</code>:</p>
      <pre><code class="typescript language-typescript">const tabStyle = {
  padding: '4px 8px',
  backgroundColor: '#f2f3fe',
  color: '#87a7ff',
  borderRadius: '4px',
};
</code></pre>
      <p>I also wanted to build tests for this component trying to think of its behavior:</p>
      <ul>
        <li>when it's not visible: the tag will not be in the document.</li>
      </ul>
      <pre><code class="typescript language-typescript">describe('when is not visible', () =&gt; {
  it('does not render anything', () =&gt; {
    const { queryByTestId } = render(
      &lt;Tag label="a label" isVisible={false} isLoading={false} /&gt;
    );

    expect(queryByTestId('tag-label-wrapper')).not.toBeInTheDocument();
  });
});
</code></pre>
      <ul>
        <li>when it's loading: the skeleton will be in the document.</li>
      </ul>
      <pre><code class="typescript language-typescript">describe('when is loading', () =&gt; {
  it('renders the tag label', () =&gt; {
    const { queryByTestId } = render(
      &lt;Tag label="a label" isVisible isLoading /&gt;
    );

    expect(queryByTestId('tag-skeleton-loader')).toBeInTheDocument();
  });
});
</code></pre>
      <ul>
        <li>when it's ready to render: the tag will be in the document.</li>
      </ul>
      <pre><code class="typescript language-typescript">describe('when is visible and not loading', () =&gt; {
  it('renders the tag label', () =&gt; {
    render(&lt;Tag label="a label" isVisible isLoading={false} /&gt;);

    expect(screen.getByText('a label')).toBeInTheDocument();
  });
});
</code></pre>
      <ul>
        <li>bonus point: accessibility. I also built an automated test to cover accessibility violations using
          <code>jest-axe</code>.</li>
      </ul>
      <pre><code class="typescript language-typescript">it('has no accessibility violations', async () =&gt; {
  const { container } = render(
    &lt;Tag label="a label" isVisible isLoading={false} /&gt;
  );

  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
</code></pre>
      <p>We are ready to implement another component: the <code>TitleDescription</code>. It will work almost similar to
        the <code>Tag</code> component. It receives some props: <code>name</code>, <code>description</code>, and
        <code>isLoading</code>.</p>
      <p>As we have the <code>Product</code> type with the type definition for the <code>name</code> and the
        <code>description</code>, I wanted to reuse it. I tried different things - and you can <a
          href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html">take a look
          here for more details</a> - and I found the <code>Pick</code> type. With that, I could get the
        <code>name</code> and the <code>description</code> from the <code>ProductType</code>:</p>
      <pre><code class="typescript language-typescript">type TitleDescriptionType = Pick&lt;ProductType, 'name' | 'description'&gt;;
</code></pre>
      <p>With this new type, I could create the <code>TitleDescriptionPropsType</code> for the component:</p>
      <pre><code class="typescript language-typescript">type TitleDescriptionPropsType = TitleDescriptionType &amp; {
  isLoading: boolean;
};
</code></pre>
      <p>Now working inside the component, If the <code>isLoading</code> is true, the component renders the proper
        skeleton component before it renders the actual title and description texts.</p>
      <pre><code class="typescript language-typescript">if (isLoading) {
  return (
    &lt;Fragment&gt;
      &lt;Skeleton
        width="60%"
        height="24px"
        data-testid="name-skeleton-loader"
      /&gt;
      &lt;Skeleton
        style={descriptionSkeletonStyle}
        height="20px"
        data-testid="description-skeleton-loader"
      /&gt;
    &lt;/Fragment&gt;
  );
}
</code></pre>
      <p>If the component is not loading anymore, we render the title and description texts. Here we use the
        <code>Typography</code> component.</p>
      <pre><code class="typescript language-typescript">return (
  &lt;Fragment&gt;
    &lt;Typography data-testid="product-name"&gt;{name}&lt;/Typography&gt;
    &lt;Typography
      data-testid="product-description"
      color="textSecondary"
      variant="body2"
      style={descriptionStyle}
    &gt;
      {description}
    &lt;/Typography&gt;
  &lt;/Fragment&gt;
);
</code></pre>
      <p>For the tests, we want three things:</p>
      <ul>
        <li>when it is loading, the component renders the skeletons</li>
        <li>when it is not loading anymore, the component renders the texts</li>
        <li>make sure the component doesn't violate the accessibility</li>
      </ul>
      <p>We will use the same idea we use for the <code>Tag</code> tests: see if it in the document or not based on the
        state.</p>
      <p>When it is loading, we want to see if the skeleton is in the document, but the title and description texts are
        not.</p>
      <pre><code class="typescript language-typescript">describe('when is loading', () =&gt; {
  it('does not render anything', () =&gt; {
    const { queryByTestId } = render(
      &lt;TitleDescription
        name={product.name}
        description={product.description}
        isLoading
      /&gt;
    );

    expect(queryByTestId('name-skeleton-loader')).toBeInTheDocument();
    expect(queryByTestId('description-skeleton-loader')).toBeInTheDocument();
    expect(queryByTestId('product-name')).not.toBeInTheDocument();
    expect(queryByTestId('product-description')).not.toBeInTheDocument();
  });
});
</code></pre>
      <p>When it is not loading anymore, it renders the texts in the DOM:</p>
      <pre><code class="typescript language-typescript">describe('when finished loading', () =&gt; {
  it('renders the product name and description', () =&gt; {
    render(
      &lt;TitleDescription
        name={product.name}
        description={product.description}
        isLoading={false}
      /&gt;
    );

    expect(screen.getByText(product.name)).toBeInTheDocument();
    expect(screen.getByText(product.description)).toBeInTheDocument();
  });
});
</code></pre>
      <p>And a simple test to cover accessibility issues:</p>
      <pre><code class="typescript language-typescript">it('has no accessibility violations', async () =&gt; {
  const { container } = render(
    &lt;TitleDescription
      name={product.name}
      description={product.description}
      isLoading={false}
    /&gt;
  );

  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
</code></pre>
      <p>The next component is the <code>Price</code>. In this component we will provide a skeleton when it is still
        loading as we did in the other component, and add three different components here:</p>
      <ul>
        <li><code>PriceWithDiscount</code>: we apply the discount into the original price and render it</li>
        <li><code>OriginalPrice</code>: it just renders the product price</li>
        <li><code>Discount</code>: it renders the discount percentage when the product has a discount</li>
      </ul>
      <p>But before I start implementing these components, I wanted to structure the data to be used. The
        <code>price</code> and the <code>discount</code> values are numbers. So let's build a function called
        <code>getPriceInfo</code> that receives the <code>price</code> and the <code>discount</code> and it will return
        this data:</p>
      <pre><code class="typescript language-typescript">{
  priceWithDiscount,
  originalPrice,
  discountOff,
  hasDiscount,
};
</code></pre>
      <p>With this type contract:</p>
      <pre><code class="typescript language-typescript">type PriceInfoType = {
  priceWithDiscount: string;
  originalPrice: string;
  discountOff: string;
  hasDiscount: boolean;
};
</code></pre>
      <p>In this function, it will get the <code>discount</code> and transform it into a <code>boolean</code>, then
        apply the <code>discount</code> to build the <code>priceWithDiscount</code>, use the <code>hasDiscount</code> to
        build the discount percentage, and build the <code>originalPrice</code> with the dollar sign:</p>
      <pre><code class="typescript language-typescript">export const applyDiscount = (price: number, discount: number): number =&gt;
  price - (price * discount) / 100;

export const getPriceInfo = (
  price: number,
  discount: number
): PriceInfoType =&gt; {
  const hasDiscount: boolean = Boolean(discount);
  const priceWithDiscount: string = hasDiscount
    ? `${applyDiscount(price, discount)}`
    : `${price}`;

  const originalPrice: string = `${price}`;
  const discountOff: string = hasDiscount ? `${discount}% OFF` : '';

  return {
    priceWithDiscount,
    originalPrice,
    discountOff,
    hasDiscount,
  };
};
</code></pre>
      <p>Here I also built an <code>applytDiscount</code> function to extract the discount calculation.</p>
      <p>I added some tests to cover these functions. As they are pure functions, we just need to pass some values and
        expect new data.</p>
      <p>Test for the <code>applyDiscount</code>:</p>
      <pre><code class="typescript language-typescript">describe('applyDiscount', () =&gt; {
  it('applies 20% discount in the price', () =&gt; {
    expect(applyDiscount(100, 20)).toEqual(80);
  });

  it('applies 95% discount in the price', () =&gt; {
    expect(applyDiscount(100, 95)).toEqual(5);
  });
});
</code></pre>
      <p>Test for the <code>getPriceInfo</code>:</p>
      <pre><code class="typescript language-typescript">describe('getPriceInfo', () =&gt; {
  describe('with discount', () =&gt; {
    it('returns the correct price info', () =&gt; {
      expect(getPriceInfo(100, 20)).toMatchObject({
        priceWithDiscount: '$80',
        originalPrice: 'article00',
        discountOff: '20% OFF',
        hasDiscount: true,
      });
    });
  });

  describe('without discount', () =&gt; {
    it('returns the correct price info', () =&gt; {
      expect(getPriceInfo(100, 0)).toMatchObject({
        priceWithDiscount: 'article00',
        originalPrice: 'article00',
        discountOff: '',
        hasDiscount: false,
      });
    });
  });
});
</code></pre>
      <p>Now we can use the <code>getPriceInfo</code> in the <code>Price</code> components to get this structure data
        and pass down for the other components like this:</p>
      <pre><code class="typescript language-typescript">export const Price = ({ price, discount, isLoading }: PricePropsType) =&gt; {
  if (isLoading) {
    return (
      &lt;Skeleton width="80%" height="18px" data-testid="price-skeleton-loader" /&gt;
    );
  }

  const {
    priceWithDiscount,
    originalPrice,
    discountOff,
    hasDiscount,
  }: PriceInfoType = getPriceInfo(price, discount);

  return (
    &lt;Fragment&gt;
      &lt;PriceWithDiscount price={priceWithDiscount} /&gt;
      &lt;OriginalPrice hasDiscount={hasDiscount} price={originalPrice} /&gt;
      &lt;Discount hasDiscount={hasDiscount} discountOff={discountOff} /&gt;
    &lt;/Fragment&gt;
  );
};
</code></pre>
      <p>As we talked earlier, when it is loading, we just render the <code>Skeleton</code> component. When it finishes
        the loading, it will build the structured data and render the price info. Let's build each component now!</p>
      <p>Let's start with the <code>OriginalPrice</code>. We just need to pass the <code>price</code> as a prop and it
        renders with the <code>Typography</code> component.</p>
      <pre><code class="typescript language-typescript">type OriginalPricePropsType = {
  price: string;
};

export const OriginalPrice = ({ price }: OriginalPricePropsType) =&gt; (
  &lt;Typography display="inline" style={originalPriceStyle} color="textSecondary"&gt;
    {price}
  &lt;/Typography&gt;
);
</code></pre>
      <p>Very simple! Let's add a test now.</p>
      <p>Just pass a price and see it if was rendered in the DOM:</p>
      <pre><code class="typescript language-typescript">it('shows the price', () =&gt; {
  const price = '$200';
  render(&lt;OriginalPrice price={price} /&gt;);
  expect(screen.getByText(price)).toBeInTheDocument();
});
</code></pre>
      <p>I also added a test to cover accessibility issues:</p>
      <pre><code class="typescript language-typescript">it('has no accessibility violations', async () =&gt; {
  const { container } = render(&lt;OriginalPrice price="$200" /&gt;);
  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
</code></pre>
      <p>The <code>PriceWithDiscount</code> component has a very similar implementation, but we pass the
        <code>hasDiscount</code> boolean to render this price or not. If it has a discount, render the price with the
        discount. Otherwise, it won't render anything.</p>
      <pre><code class="typescript language-typescript">type PricePropsType = {
  hasDiscount: boolean;
  price: string;
};
</code></pre>
      <p>The props type has the <code>hasDiscount</code> and the <code>price</code>. And the component just renders
        things based on the <code>hasDiscount</code> value.</p>
      <pre><code class="typescript language-typescript">export const PriceWithDiscount = ({ price, hasDiscount }: PricePropsType) =&gt; {
  if (!hasDiscount) {
    return null;
  }

  return (
    &lt;Typography display="inline" style={priceWithDiscountStyle}&gt;
      {price}
    &lt;/Typography&gt;
  );
};
</code></pre>
      <p>The tests will cover this logic when it has or doesn't have the discount. If it hasn't the discount, the prices
        will not be rendered.</p>
      <pre><code class="typescript language-typescript">describe('when the product has no discount', () =&gt; {
  it('shows nothing', () =&gt; {
    const { queryByTestId } = render(
      &lt;PriceWithDiscount hasDiscount={false} price="" /&gt;
    );

    expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();
  });
});
</code></pre>
      <p>If it has the discount, it will be the rendered in the DOM:</p>
      <pre><code class="typescript language-typescript">describe('when the product has a discount', () =&gt; {
  it('shows the price', () =&gt; {
    const price = '$200';
    render(&lt;PriceWithDiscount hasDiscount price={price} /&gt;);
    expect(screen.getByText(price)).toBeInTheDocument();
  });
});
</code></pre>
      <p>And as always, a test to cover accessibility violations:</p>
      <pre><code class="typescript language-typescript">it('has no accessibility violations', async () =&gt; {
  const { container } = render(
    &lt;PriceWithDiscount hasDiscount price="$200" /&gt;
  );

  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
</code></pre>
      <p>The <code>Discount</code> component is pretty much the same as the <code>PriceWithDiscount</code>. Render the
        discount tag if the product has a discount:</p>
      <pre><code class="typescript language-typescript">type DiscountPropsType = {
  hasDiscount: boolean;
  discountOff: string;
};

export const Discount = ({ hasDiscount, discountOff }: DiscountPropsType) =&gt; {
  if (!hasDiscount) {
    return null;
  }

  return (
    &lt;Typography
      display="inline"
      color="secondary"
      data-testid="discount-off-label"
    &gt;
      {discountOff}
    &lt;/Typography&gt;
  );
};
</code></pre>
      <p>And all the tests we did for the other component, we do the same thing for the <code>Discount</code> component:
      </p>
      <pre><code class="typescript language-typescript">describe('Discount', () =&gt; {
  describe('when the product has a discount', () =&gt; {
    it('shows the discount label', () =&gt; {
      const discountOff = '20% OFF';
      render(&lt;Discount hasDiscount discountOff={discountOff} /&gt;);
      expect(screen.getByText(discountOff)).toBeInTheDocument();
    });
  });

  describe('when the product has no discount', () =&gt; {
    it('shows nothing', () =&gt; {
      const { queryByTestId } = render(
        &lt;Discount hasDiscount={false} discountOff="" /&gt;
      );

      expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();
    });
  });

  it('has no accessibility violations', async () =&gt; {
    const { container } = render(
      &lt;Discount hasDiscount discountOff="20% OFF" /&gt;
    );

    const results = await axe(container);

    expect(results).toHaveNoViolations();
  });
});
</code></pre>
      <p>Now we will build an <code>Image</code> component. This component has the basic skeleton as any other component
        we've built. If it is loading, wait to render the image source and render the skeleton instead. When it finishes
        the loading, we will render the image, but only if the component is in the intersection of the browser window.
      </p>
      <p>What does it mean? When you are on a website on your mobile device, you'll probably see the first 4 products.
        They will render the skeleton and then the image. But below these 4 products, as you're not seeing any of them,
        it doesn't matter if we are rendering them or not. And we can choose to not render them. Not for now. But
        on-demand. When you are scrolling, if the product's image is at the intersection of the browser window, we start
        rendering the image source.</p>
      <p>That way we gain performance by speeding up the page load time and reduce the cost by requesting images on
        demand.</p>
      <p>We will use the Intersection Observer API to download images on demand. But before writing any code about this
        technology, let's start building our component with the image and the skeleton view.</p>
      <p>Image props will have this object:</p>
      <pre><code class="typescript language-typescript">{
  imageUrl,
  imageAlt,
  width,
  isLoading,
  imageWrapperStyle,
  imageStyle,
}
</code></pre>
      <p>The <code>imageUrl</code>, <code>imageAlt</code>, and the <code>isLoading</code> props are passed by the
        product component. The <code>width</code> is an attribute for the skeleton and the image tag. The
        <code>imageWrapperStyle</code> and the <code>imageStyle</code> are props that have a default value in the image
        component. We'll talk about this later.</p>
      <p>Let's add a type for this props:</p>
      <pre><code class="typescript language-typescript">type ImageUrlType = Pick&lt;ProductType, 'imageUrl'&gt;;
type ImageAttrType = { imageAlt: string; width: string };
type ImageStateType = { isLoading: boolean };
type ImageStyleType = {
  imageWrapperStyle: CSSProperties;
  imageStyle: CSSProperties;
};

export type ImagePropsType = ImageUrlType &amp;
  ImageAttrType &amp;
  ImageStateType &amp;
  ImageStyleType;
</code></pre>
      <p>The idea here is to give meaning for the types and then compose everything. We can get the
        <code>imageUrl</code> from the <code>ProductType</code>. The attribute type will have the <code>imageAlt</code>
        and the <code>width</code>. The image state has the <code>isLoading</code> state. And the image style has some
        <code>CSSProperties</code>.</p>
      <p>At first, the component would like this:</p>
      <pre><code class="typescript language-typescript">export const Image = ({
  imageUrl,
  imageAlt,
  width,
  isLoading,
  imageWrapperStyle,
  imageStyle,
}: ImagePropsType) =&gt; {
  if (isLoading) {
    &lt;Skeleton
      variant="rect"
      width={width}
      data-testid="image-skeleton-loader"
    /&gt;
  }

  return (
    &lt;img
      src={imageUrl}
      alt={imageAlt}
      width={width}
      style={imageStyle}
    /&gt;
  );
};
</code></pre>
      <p>Let's build the code to make the intersection observer works.</p>
      <p>The idea of the intersection observer is to receive a target to be observed and a callback function that is
        executed whenever the observed target enters or exits the viewport. So the implementation would be very simple:
      </p>
      <pre><code class="typescript language-typescript">const observer: IntersectionObserver = new IntersectionObserver(
  onIntersect,
  options
);

observer.observe(target);
</code></pre>
      <p>Instantiate the <code>IntersectionObserver</code> class by passing an options object and the callback function.
        The <code>observer</code> will observe the <code>target</code> element.</p>
      <p>As it is an effect in the DOM, we can wrap this into a <code>useEffect</code>.</p>
      <pre><code class="typescript language-typescript">useEffect(() =&gt; {
  const observer: IntersectionObserver = new IntersectionObserver(
    onIntersect,
    options
  );

  observer.observe(target);

  return () =&gt; {
    observer.unobserve(target);
  };
}, [target]);
</code></pre>
      <p>Using <code>useEffect</code>, we have two different things here: the dependency array and the returning
        function. We pass the <code>target</code> as the dependency function to make sure that we will re-run the effect
        if the <code>target</code> changes. And the returning function is a cleanup function. React performs the cleanup
        when the component unmounts, so it will clean up the effect before running another effect for every render.</p>
      <p>In this cleanup function, we just stop observing the <code>target</code> element.</p>
      <p>When the component starts rendering, the <code>target</code> reference is not set yet, so we need to have a
        guard to not observe an <code>undefined</code> target.</p>
      <pre><code class="typescript language-typescript">useEffect(() =&gt; {
  if (!target) {
    return;
  }

  const observer: IntersectionObserver = new IntersectionObserver(
    onIntersect,
    options
  );

  observer.observe(target);

  return () =&gt; {
    observer.unobserve(target);
  };
}, [target]);
</code></pre>
      <p>Instead of using this effect in our component, we could build a custom hook to receive the target, some options
        to customize the configuration, and it would provide a boolean telling if the target is at the intersection of
        the viewport or not.</p>
      <pre><code class="typescript language-typescript">export type TargetType = Element | HTMLDivElement | undefined;
export type IntersectionStatus = {
  isIntersecting: boolean;
};

const defaultOptions: IntersectionObserverInit = {
  rootMargin: '0px',
  threshold: 0.1,
};

export const useIntersectionObserver = (
  target: TargetType,
  options: IntersectionObserverInit = defaultOptions
): IntersectionStatus =&gt; {
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() =&gt; {
    if (!target) {
      return;
    }

    const onIntersect = ([entry]: IntersectionObserverEntry[]) =&gt; {
      setIsIntersecting(entry.isIntersecting);

            if (entry.isIntersecting) {
        observer.unobserve(target);
      }
    };

    const observer: IntersectionObserver = new IntersectionObserver(
      onIntersect,
      options
    );

    observer.observe(target);

    return () =&gt; {
      observer.unobserve(target);
    };
  }, [target]);

  return { isIntersecting };
};
</code></pre>
      <p>In our callback function, we just set if the entry target is intersecting the viewport or not. The
        <code>setIsIntersecting</code> is a setter from the <code>useState</code> hook we define at the top of our
        custom hook.</p>
      <p>It is initialized as <code>false</code> but will update to <code>true</code> if it is intersecting the
        viewport.</p>
      <p>With this new information in the component, we can render the image or not. If it is intersecting, we can
        render the image. If not, just render a skeleton until the user gets to the viewport intersection of the product
        image.</p>
      <p>How does it look in practice?</p>
      <p>First we define the wrapper reference using <code>useState</code>:</p>
      <pre><code class="typescript language-typescript">const [wrapperRef, setWrapperRef] = useState&lt;HTMLDivElement&gt;();
</code></pre>
      <p>It start as <code>undefined</code>. Then build a wrapper callback to set the element node:</p>
      <pre><code class="typescript language-typescript">const wrapperCallback = useCallback(node =&gt; {
  setWrapperRef(node);
}, []);
</code></pre>
      <p>With that, we can use it to get the wrapper reference by using a <code>ref</code> prop in our <code>div</code>.
      </p>
      <pre><code class="typescript language-typescript">&lt;div ref={wrapperCallback}&gt;
</code></pre>
      <p>After setting the <code>wrapperRef</code>, we can pass it as the <code>target</code> for our
        <code>useIntersectionObserver</code> and expect a <code>isIntersecting</code> status as a result:</p>
      <pre><code class="typescript language-typescript">const { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);
</code></pre>
      <p>With this new value, we can build a boolean value to know if we render the skeleton or the product image.</p>
      <pre><code class="typescript language-typescript">const showImageSkeleton: boolean = isLoading || !isIntersecting;
</code></pre>
      <p>So now we can render the appropriate node to the DOM.</p>
      <pre><code class="typescript language-typescript">&lt;div ref={wrapperCallback} style={imageWrapperStyle}&gt;
  {showImageSkeleton ? (
    &lt;Skeleton
      variant="rect"
      width={width}
      height={imageWrapperStyle.height}
      style={skeletonStyle}
      data-testid="image-skeleton-loader"
    /&gt;
  ) : (
    &lt;img
      src={imageUrl}
      alt={imageAlt}
      width={width}
    /&gt;
  )}
&lt;/div&gt;
</code></pre>
      <p>The full component looks like this:</p>
      <pre><code class="typescript language-typescript">export const Image = ({
  imageUrl,
  imageAlt,
  width,
  isLoading,
  imageWrapperStyle,
}: ImagePropsType) =&gt; {
  const [wrapperRef, setWrapperRef] = useState&lt;HTMLDivElement&gt;();
  const wrapperCallback = useCallback(node =&gt; {
    setWrapperRef(node);
  }, []);

  const { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);
  const showImageSkeleton: boolean = isLoading || !isIntersecting;

  return (
    &lt;div ref={wrapperCallback} style={imageWrapperStyle}&gt;
      {showImageSkeleton ? (
        &lt;Skeleton
          variant="rect"
          width={width}
          height={imageWrapperStyle.height}
          style={skeletonStyle}
          data-testid="image-skeleton-loader"
        /&gt;
      ) : (
        &lt;img
          src={imageUrl}
          alt={imageAlt}
          width={width}
        /&gt;
      )}
    &lt;/div&gt;
  );
};
</code></pre>
      <p>Great, now the loading on-demand works well. But I want to build a slightly better experience. The idea here is
        to have two different sizes of the same image. The low-quality image is requested and we make it visible, but
        blur while the high-quality image is requested in the background. When the high-quality image finally finishes
        loading, we transition from the low-quality to the high-quality image with an ease-in/ease-out transition to
        make it a smooth experience.</p>
      <p>Let's build this logic. We could build this into the component, but we could also extract this logic into a
        custom hook.</p>
      <pre><code class="typescript language-typescript">export const useImageOnLoad = (): ImageOnLoadType =&gt; {
  const [isLoaded, setIsLoaded] = useState(false);
  const handleImageOnLoad = () =&gt; setIsLoaded(true);

  const imageVisibility: CSSProperties = {
    visibility: isLoaded ? 'hidden' : 'visible',
    filter: 'blur(10px)',
    transition: 'visibility 0ms ease-out 500ms',
  };

  const imageOpactity: CSSProperties = {
    opacity: isLoaded ? 1 : 0,
    transition: 'opacity 500ms ease-in 0ms',
  };

  return { handleImageOnLoad, imageVisibility, imageOpactity };
};
</code></pre>
      <p>This hook just provides some data and behavior for the component. The <code>handleImageOnLoad</code> we talked
        earlier, the <code>imageVisibility</code> to make the low-quality image visible or not, and the
        <code>imageOpactity</code> to make the transition from transparent to opaque, that way we make it visible after
        loading it.</p>
      <p>The <code>isLoaded</code> is a simple boolean to handle the visibility of the images. Another small detail is
        the <code>filter: 'blur(10px)'</code> to make the low-quality-image blur and then slowly focusing while
        transitioning from the low-quality image to the high-quality image.</p>
      <p>With this new hook, we just import it, and call inside the component:</p>
      <pre><code class="typescript language-typescript">const {
  handleImageOnLoad,
  imageVisibility,
  imageOpactity,
}: ImageOnLoadType = useImageOnLoad();
</code></pre>
      <p>And start using the data and behavior we built.</p>
      <pre><code class="typescript language-typescript">&lt;Fragment&gt;
  &lt;img
    src={thumbUrl}
    alt={imageAlt}
    width={width}
    style={{ ...imageStyle, ...imageVisibility }}
  /&gt;
  &lt;img
    onLoad={handleImageOnLoad}
    src={imageUrl}
    alt={imageAlt}
    width={width}
    style={{ ...imageStyle, ...imageOpactity }}
  /&gt;
&lt;/Fragment&gt;
</code></pre>
      <p>The first one has a low-quality image, the <code>thumbUrl</code>. The second has the original high-quality
        image, the <code>imageUrl</code>. When the high-quality image is loaded, it calls the
        <code>handleImageOnLoad</code> function. This function will make the transition between one image to the other.
      </p>
      <h2 id="wrappingup">Wrapping up</h2>
      <p>This is the first part of this project to learn more about user experience, native APIs, typed frontend, and
        tests.</p>
      <p>For the next part of this series, we are going to think more in an architectural way to build the search with
        filters, but keeping the mindset to bring technical solutions to make the user experience as smooth as possible.
      </p>
      <h2 id="resources">Resources</h2>
      <ul>
        <li><a
            href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video">Lazy
            Loading Images and Video</a></li>
        <li><a
            href="https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/">Functional
            Uses for Intersection Observer</a></li>
        <li><a href="https://css-tricks.com/tips-for-rolling-your-own-lazy-loading/">Tips for rolling your own lazy
            loading</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer
            API - MDN</a></li>
        <li><a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet">React Typescript
            Cheatsheet</a></li>
      </ul>
    </article>

    <iframe src="https://teekay.substack.com/embed" width="100%" height="300"
      style="border:1px solid #EEE; background:white;" frameborder="0" scrolling="no"></iframe>

    <div class="meta meta-footer">
      <div class="article-tag">
        Tags:
        <a class="tag-link" href="../../../tags/javascript.html">javascript</a>
        <a class="tag-link" href="../../../tags/typescript.html">typescript</a>
        <a class="tag-link" href="../../../tags/web_development.html">web_development</a>

      </div>
    </div>

    <div class="support-buttons">
      <a class="patreon-button" href="https://www.patreon.com/iamteekay" target="_blank" rel="noopener noreferrer">
        <img
          src="data:image/png;base64,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"
          height="50" width="50" alt="Patreon">
        Become a Patron
      </a>

      <a href="https://ko-fi.com/teekay" class="kofi-button" target="_blank" rel="noopener noreferrer">
        <img
          src="data:image/png;base64,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"
          class="coffee-icon" alt="Coffee icon">
        Buy me a coffee
      </a>
    </div>
  </div>

  <footer id="footer" class="article-footer">
    <div class="footer-left">
      Copyright &copy; 2020 TK
    </div>
    <div class="footer-right">
      <nav>
        <ul>
          <li><a href="../../../index.html">Home</a></li>
          <li><a href="../../../writing.html">Writing</a></li>
          <li><a href="https://github.com/leandrotk" target="_blank">Projects</a></li>
          <li><a href="../../../quotes.html">Quotes</a></li>
        </ul>
      </nav>
    </div>
  </footer>

  <script src="../../../javascripts/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>
