<!DOCTYPE html>
<html lang=en>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description"
    content="Types can be hard and this long-format essay tries to give a way of thinking about types and Typescript">
  <meta name="keywords" content="typescript,javascript,web_development">
  <meta property="og:type" content="article">
  <meta property="og:title" content="A Mental Model to think in Typescript">
  <meta property="og:description"
    content="Types can be hard and this long-format essay tries to give a way of thinking about types and Typescript">
  <meta property="og:locale" content="en">
  <meta property="og:image" content="assets/cover.jpg">
  <meta property="og:updated_time" content="2020-07-19T00:00:00.000Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="A Mental Model to think in Typescript">
  <meta name="twitter:description"
    content="Types can be hard and this long-format essay tries to give a way of thinking about types and Typescript">
  <meta name="twitter:image" content="assets/cover.jpg">

  <title>A Mental Model to think in Typescript</title>
  <link rel="stylesheet" type="text/css" href="../../../stylesheets/main.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css"
    integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/styles/night-owl.min.css">
</head>

<body>
  <div class="content index width mx-auto px2 my4">
    <div id="header-post">
      <a id="menu-icon" href="../../../index.html">
        <i class="fas fa-long-arrow-alt-left"></i>
        Home
      </a>
    </div>
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
      <header>
        <h1 class="posttitle">A Mental Model to think in Typescript</h1>
        <div class="meta">
          <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span itemprop="name">TK</span>
          </span>

          <div class="postdate">
            <time datetime="2020-07-19T00:00:00.000Z" itemprop="datePublished">2020-07-19</time>
          </div>

          <div class="article-tag">
            <i class=b fa-tag"></i>
            <a class="tag-link" href="../../../tags/typescript.html">typescript</a>
            <a class="tag-link" href="../../../tags/javascript.html">javascript</a>
            <a class="tag-link" href="../../../tags/web_development.html">web_development</a>

          </div>
        </div>
      </header>

      <div class="figure">
        <img src="assets/cover.jpg" alt="A photo of the universe">
        <span class="figcaption">
          Photo by <a href="https://unsplash.com/@fabrizioverrecchia" target="_blank">Fabrizio Verrecchia</a>
        </span>
      </div>

      <hr />

      <p>One day I came across a <a href="https://twitter.com/larimaza/status/1275747670989176833">tweet</a> from Lari
        Mazza that says</p>
      <blockquote>
        <p>"Can I make a suggestion? Types are hard to understand when you’ve only worked with JS in your life and
          suddenly have to learn TypeScript"</p>
      </blockquote>
      <p>As a software engineer that learned Python, Ruby, Javascript, and Clojure first, when I tried C++, it was a
        horror movie. I couldn't do much, so counterproductive, and frustrating. Maybe because I was doing everything
        wrong and I didn't understand types the right way.</p>
      <p>But even though I had so many problems, I could implement a bunch of <a
          href="https://github.com/leandrotk/algorithms">algorithms and data structures</a>.</p>
      <p>Now I'm using more and more Typescript in my day-to-day job and in <a
          href="https://github.com/leandrotk/laziness">my side projects</a>, I feel I'm more prepared to confront types.
        Actually, not confront, but use them in my favor.</p>
      <p>This post is my attempt to help developers think more in types and understand this mental model.</p>
      <h2 id="javascripttypes">Javascript types</h2>
      <p>If you're here, you probably heard that Typescript is a superset of Javascript. If not, great, you had just
        learned
        something new today. YAY!</p>
      <p>Typescript is a superset because any Javascript code is valid in Typescript, syntactically speaking. It may or
        may not compile depending on the Typescript compiler configuration. But in terms of syntax, it works just fine.
        This is why you can migrate Javascript to Typescript progressively by just replacing the <code>.js</code>
        extension with the <code>.ts</code>. Everything will be without type declarations (the <code>any</code> type),
        but that's another story.</p>
      <p>Also, if you code in Javascript - or any other programming language - you probably think in types:</p>
      <ul>
        <li>"Hm, it is a list of integers, so I'll need to filter only the even numbers and return a new list"</li>
        <li>"This is an object, but I just need to get this string value from the property X"</li>
        <li>"This function receives two parameters. Both A and B are integers and I want to sum them"</li>
      </ul>
      <p>Yeah, you got the idea. We think in types. But they are just in our heads. We constantly think about them
        because we need to know how to handle, parse, or modify data. We need to know which methods we are allowed to
        use in this object type.</p>
      <p>To give a more concrete example, imagine you want to sum the price of all products. A product object looks like
        this:</p>
      <pre><code class="typescript language-typescript">const product = {
  title: 'Some product',
  price: 100.00,
};
</code></pre>
      <p>But now with a list of products:</p>
      <pre><code class="typescript language-typescript">const products = [
  {
    title: 'Product 1',
    price: 100.00,
  },
  {
    title: 'Product 2',
    price: 25.00,
  },
  {
    title: 'Product 3',
    price: 300.00,
  }
];
</code></pre>
      <p>Ok! Now we want a function to sum all the product prices.</p>
      <pre><code class="typescript language-typescript">function sumAllPrices(products) {
  return products.reduce((sum, product) =&gt; sum + product.price, 0);
};

sumAllPrices(products); // 425
</code></pre>
      <p>Just receive the products as the argument and reduce all product prices. Javascript works just fine. But while
        building this function you start to think about the data and how to handle it properly.</p>
      <p>The first part: products as an argument. Here you just think: "well, we're receiving a list of some objects".
        Yeah, in our heads the products are a list. This is why we can think of using the <code>reduce</code> method. It
        is a method from the <code>Array</code> prototype.</p>
      <p>Then we can think about the object in detail. We know that the product object has a <code>price</code>
        property. And this property is a number. This is why we can do <code>product.price</code> and sum with the
        accumulator.</p>
      <p>Recapping:</p>
      <ul>
        <li><code>products</code> is a list of objects.</li>
        <li>As a list, we can use the <code>reduce</code> method, as this method is a member of the <code>Array</code>
          prototype.</li>
        <li>The <code>product</code> object has some properties. One of them is the <code>price</code>, which is a
          number.</li>
        <li>As a number property, we can use it to sum with the reduce accumulator.</li>
        <li>We wanted to return the a number, the sum of all product prices.</li>
      </ul>
      <p>We are always thinking of data types, we just need to add the type annotations to make it more explicit and ask
        the compiler for help. Our memory is limited and the compilers are here to help us, humans.</p>
      <p>The type system will not only make our data more consistent, but it can also provide autocompletion for data
        types. It knows the types, so it can show the members of the data. We will take a look at this idea later. Here
        I just wanted to show that we think in types in our heads.</p>
      <h2 id="simplestypessimpleuses">Simples Types &amp; Simple Uses</h2>
      <p>So we are ready to use some static typed programming languages like Typescript. We simply need to explicitly
        add type annotations to our data structures. It's simple. But sometimes it's not that easy (usually it's not
        easy when you come from dynamically typed languages. You feel unproductive. It feels like a battle against
        types. The idea here is to make this learning curve more smooth and fun).</p>
      <p>Here we will see many examples of how to use types in Typescript. We start with easy and silly examples and
        progressively make it more complex while designing the mental model to think in types.</p>
      <p>As Javascript, Typescript also has basic data types like <code>number</code>, <code>string</code>,
        <code>boolean</code>, <code>null</code>, etc. You can find all the basic data types in the <a
          href="https://www.typescriptlang.org/docs/handbook/basic-types.html">Typescript Docs</a>.</p>
      <p>With these units of data, we can make our programs more useful. To be more practical, let's get a simple
        example. A <code>sum</code> function.</p>
      <p>How does it work in Javascript?</p>
      <pre><code class="typescript language-typescript">function sum(a, b) {
  return a + b;
}
</code></pre>
      <p>Everything ok? ok.</p>
      <p>Now let's use it:</p>
      <pre><code class="typescript language-typescript">sum(1, 2); // 3
sum(2, 2); // 4
sum(0, 'string'); // '0string'   WTF!
</code></pre>
      <p>The first two calls are what we expect to happen in our system. But Javascript is very flexible, it lets us
        provide any value to this function. The last call is bizarre. We can call with a string, but it will return an
        unexpected result. It doesn't break in development, but it will result in strange behavior in runtime.</p>
      <p>What do we want? We want to add some constraints to the function. It will only be able to receive numbers. That
        way, we narrow the possibility to have unexpected behaviors. And the function return type is also a number.</p>
      <pre><code class="typescript language-typescript">function sum(a: number, b: number): number {
  return a + b;
}
</code></pre>
      <p>Great! It was very simple. Let's call again.</p>
      <pre><code class="typescript language-typescript">sum(1, 2); // 3
sum(2, 2); // 4
sum(0, 'string'); // Argument of type '"string"' is not assignable to parameter of type 'number'.
</code></pre>
      <p>As we type annotate our function, we provide information to the compiler to see if everything is correct. It
        will follow the constraints we added to the function.</p>
      <p>So the first two calls are the same as in Javascript. It will return the correct calculation. But the last one
        we have an error in compile time. This is important. The error now happens in compile time and prevents us to
        ship incorrect code to production. It says that the <code>string</code> type is not part of the set of values in
        the <code>number</code> type universe.</p>
      <p>For basic types, we just need to add colon followed by the type definition.</p>
      <pre><code class="typescript language-typescript">const isTypescript: boolean = true;
const age: number = 24;
const username: string = 'tk';
</code></pre>
      <p>Now let's increase the challenge. Remember the product object code we wrote in Javascript? Let's implement it
        again, but now with the Typescript mindset.</p>
      <p>Just to remember what we are talking about:</p>
      <pre><code class="typescript language-typescript">const product = {
  title: 'Some product',
  price: 100.00,
};
</code></pre>
      <p>This is the product value. It has a <code>title</code> as <code>string</code> and the <code>price</code> as
        <code>number</code>. For now, this is what we need to know.</p>
      <p>The object type would be something like:</p>
      <pre><code class="typescript language-typescript">{ title: string, price: number }
</code></pre>
      <p>And we use this type to annotate our function:</p>
      <pre><code class="typescript language-typescript">const product: { title: string, price: number } = {
  title: 'Some product',
  price: 100.00,
};
</code></pre>
      <p>With this type, the compiler will know how to handle inconsistent data:</p>
      <pre><code class="typescript language-typescript">const wrongProduct: { title: string, price: number } = {
  title: 100.00, // Type 'number' is not assignable to type 'string'.
  price: 'Some product', // Type 'string' is not assignable to type 'number'.
};
</code></pre>
      <p>Here it breaks in two different properties:</p>
      <ul>
        <li>The <code>title</code> is a <code>string</code> and should not receive a <code>number</code>.</li>
        <li>The <code>price</code> is a <code>number</code> and should not receive a <code>string</code>.</li>
      </ul>
      <p>The compiler helps us to catch type errors like that.</p>
      <p>We could improve this type annotation by using a concept called <code>Type Aliases</code>. It's a way to create
        a new name for a specific type.</p>
      <p>In our case, the product type could be:</p>
      <pre><code class="typescript language-typescript">type Product = {
  title: string;
  price: number;
};

const product: Product = {
  title: 'Some product',
  price: 100.00,
};
</code></pre>
      <p>It's better to visualize the type, add semantics, and maybe reuse in our system.</p>
      <p>Now that we have this product type, we can use it to type the products list. The syntax looks like this:
        <code>MyType[]</code>. In our case, <code>Product[]</code>.</p>
      <pre><code class="typescript language-typescript">const products: Product[] = [
  {
    title: 'Product 1',
    price: 100.00,
  },
  {
    title: 'Product 2',
    price: 25.00,
  },
  {
    title: 'Product 3',
    price: 300.00,
  }
];
</code></pre>
      <p>Now the function <code>sumAllPrices</code>. It will receive the product and return a number, the sum of all
        product prices.</p>
      <pre><code class="typescript language-typescript">function sumAllPrices(products: Product[]): number {
  return products.reduce((sum, product) =&gt; sum + product.price, 0);
};
</code></pre>
      <p>This is very interesting. As we typed the product, when we write <code>product.</code>, it will show the
        possible properties we can use. In the product type case, it will show the properties <code>price</code> and
        <code>title</code>.</p>
      <pre><code class="typescript language-typescript">sumAllPrices(products); // 425
sumAllPrices([]); // 0
sumAllPrices([{ title: 'Test', willFail: true }]); // Type '{ title: string; willFail: true; }' is not assignable to type 'Product'.
</code></pre>
      <p>Passing the <code>products</code> will result in the value <code>425</code>. An empty list will result in the
        value <code>0</code>. And if we pass an object with a different structure - Typescript has a structural type
        system and we will dig deep into this topic later - the compiler will throw a type error telling that the
        structure is not part of the <code>Product</code> type.</p>
      <h2 id="structuraltyping">Structural Typing</h2>
      <p>Structural typing is a type of type compatibility. It's a way to understand the compatibility between types
        based on its structure: features, members, properties. Some languages have type compatibility based on the names
        of the types, and it's called nominal typing.</p>
      <p>For example, in Java, even if different types have the same structure, it will throw a compile error because we
        are using a different type to instantiate and define a new instance.</p>
      <pre><code class="typescript language-typescript">class Person {
  String name;
}

class Client {
  String name;
}

Client c = new Person();  // compiler throws an error
Client c = new Client();  // OK!
</code></pre>
      <p>In nominal type systems, the relevant part of a type is the name, not the structure.</p>
      <p>Typescript, on another hand, verifies the structural compatibility to allow or not specific data. Its type
        system is based on structural typing.</p>
      <p>The same code implementation that crashes in Java, would work in Typescript.</p>
      <pre><code class="typescript language-typescript">class Person {
  name: string;
}

class Client {
  name: string;
}

const c1: Client = new Person(); // OK!
const c2: Client = new Client(); // OK!
</code></pre>
      <p>We want to use the <code>Client</code> type, and it has the property <code>name</code>, to point to the
        <code>Person</code> type. It also has the property type. So Typescript will understand that both types have the
        same shape.</p>
      <p>But it is not only about classes, but it works for any other "object".</p>
      <pre><code class="typescript language-typescript">const c3: Client = {
  name: 'TK'
};
</code></pre>
      <p>This code compiles too because we have the same structure here. The typescript type system doesn't care about
        if it is a class, or an object literal if it has the same members, it will be flexible and compile.</p>
      <p>But now we will add a third type: the <code>Customer</code>.</p>
      <pre><code class="typescript language-typescript">class Customer {
  name: string;
  age: number;
};
</code></pre>
      <p>It not only has the <code>name</code> property, but also the <code>age</code>. What would happen if we
        instantiate a <code>Client</code> instance in a constant of type <code>Customer</code>?</p>
      <pre><code class="typescript language-typescript">const c4: Customer = new Client();
</code></pre>
      <p>The compiler will not accept that. We want to use the <code>Customer</code>, that has <code>name</code> and
        <code>age</code>. But we are instantiating the <code>Client</code> that has only the <code>name</code> property.
        So it doesn't have the same shape. It will cause an error:</p>
      <pre><code class="bash language-bash">Property 'age' is missing in type 'Client' but required in type 'Customer'.
</code></pre>
      <p>The other way around would work because we want <code>Client</code>, and <code>Customer</code> has all the
        properties (<code>name</code>) from <code>Client</code>.</p>
      <pre><code class="typescript language-typescript">const c5: Client = new Customer();
</code></pre>
      <p>It works fine!</p>
      <p>We can go on for enums, object literals, and any other type, but the idea here is to understand that the
        structure of the type is the relevant part.</p>
      <h2 id="runtimeandcompiletime">Runtime and Compile time</h2>
      <p>This is a much more complex topic in programming language theory, but I wanted to give some examples to
        distinct runtime and compile time.</p>
      <p>Basically, the runtime is the execution time of a program. Imagine your backend receiving data from a frontend
        form page, handling this data, and saving it. Or when your frontend is requesting data from a server to render a
        list of <s>Pokemons</s> products.</p>
      <p>Compile time is basically when the compiler is executing operations in the source code to satisfy the
        programming language requirements. It can include type checking as an operation for example. Compile time errors
        in Typescript, for example, is very related to the code that we wrote before:</p>
      <ul>
        <li>When the type is missing property:
          <code>Property 'age' is missing in type 'Client' but required in type 'Customer'.</code></li>
        <li>When the type doesn't match:
          <code>Type '{ title: string; willFail: true; }' is not assignable to type 'Product'.</code></li>
      </ul>
      <p>Let's see some examples to have a better understanding.</p>
      <p>I want to write a function to get the index of a part of the passed programming language.</p>
      <pre><code class="typescript language-typescript">function getIndexOf(language, part) {
  return language.indexOf(part);
}
</code></pre>
      <p>It receives the <code>language</code> and the <code>part</code> that we will look for to get the index.</p>
      <pre><code class="typescript language-typescript">getIndexOf('Typescript', 'script'); // 4
getIndexOf(42, 'script'); // Uncaught TypeError: language.indexOf is not a function at getIndexOf
</code></pre>
      <p>When passing a string, it works fine. But passing a number, we got a runtime error
        <code>Uncaught TypeError</code>. Because a number doesn't have an <code>indexOf</code> function, so we can't
        really use it.</p>
      <p>But if we give type information to the compiler, in compile time, it will throw an error before running the
        code.</p>
      <pre><code class="typescript language-typescript">function getIndexOf(language: string, part: string): number {
  return language.indexOf(part);
}
</code></pre>
      <p>Now our program knows that it will need to receive two strings and return a number. The compiler can use this
        information to throw errors when we get a type error… before runtime.</p>
      <pre><code class="typescript language-typescript">getIndexOf('Typescript', 'script'); // 4
getIndexOf(42, 'script'); // Argument of type '42' is not assignable to parameter of type 'string'.
</code></pre>
      <p>Maybe, for small projects (or small functions like ours) we don't really see too much benefit. In this case, we
        know that we need to pass a string, so we won't pass a number to the function. But when the codebase grows or
        you have many people adding code and more complexity, it's clear to me that a type system can help us a lot to
        get errors in compile time before shipping code to production.</p>
      <p>At first, we need all the learning curve to understand types and all the mental models, but after a while,
        you'll be more used to type annotations and eventually become friends with the compiler. It would be a
        <em>helper</em>, not a <em>yeller</em>.</p>
      <p>As we are learning about the basic difference between compile time and runtime, I think it's great to
        differentiate types from values.</p>
      <p>All the examples I'll show here can be copied and run in the <a
          href="https://www.typescriptlang.org/play">Typescript Playground</a> to understand the compiler and the result
        of the compilation process (aka the <em>"Javascript"</em>).</p>
      <p>In Typescript, we have two different universes: the value and the type spaces. The type space is where types
        are defined and used to enable the compiler to do all the great magic. And the value space is the values in our
        programs like variables, constants, functions, value literals, and things that we have in runtime.</p>
      <p>It's good to have an understanding of this concept because in Typescript we can't use type checking in runtime.
        It has a very clear separation between type checking and the compilation process.</p>
      <p>Typescript has the process of type checking the source code types and sees if everything is correct and
        consistent. And then it can compile to Javascript. As these two parts are separate, we can't use type checking
        in runtime. Only in "compile time". If you try to use a type as a value, it will throw an error:
        <code>only refers to a type, but is being used as a value here</code>.</p>
      <p>Let's see examples of this idea.</p>
      <p>Imagine we want to write a function called <code>purchase</code> where we receive a payment method and based on
        this method, we want to do some action. We have a credit card and a debit card. Let's define them here:</p>
      <pre><code class="typescript language-typescript">type CreditCard = {
  number: number;
  cardholder: string;
  expirationDate: Date;
  secutiryCode: number;
};

type DebitCard = {
  number: number;
  cardholder: string;
  expirationDate: Date;
  secutiryCode: number;
};

type PaymentMethod = CreditCard | DebitCard;
</code></pre>
      <p>These types are in the <em>Type space</em>, so it only works in compile time. After type checking this
        function, the compiler removes all the types.</p>
      <p>If you add these types in the Typescript Playground, the output will be only a strict definition
        <code>"use strict";</code>.</p>
      <p>The idea here is to really understand that the types live in the <em>Type space</em> and will not be available
        in the runtime. So in our function, it won't be possible to do this:</p>
      <pre><code class="typescript language-typescript">const purchase = (paymentMethod: PaymentMethod) =&gt; {
  if (paymentMethod instanceof CreditCard) {
    // purchase with credit card
  } else {
    // purchase with debit card
  }
}
</code></pre>
      <p>In compiler throws an error:
        <code>'CreditCard' only refers to a type, but is being used as a value here.</code>.</p>
      <p>The compiler knows the difference between the two spaces and that the type <code>CreditCard</code> lives in the
        <em>Type space</em>.</p>
      <p>The playground is a very cool tool to see the output of your Typescript code. If you create a new credit card
        object like this:</p>
      <pre><code class="typescript language-typescript">const creditCard: CreditCard = {
  number: 2093,
  cardholder: 'TK',
  expirationDate: new Date(),
  secutiryCode: 101
};
</code></pre>
      <p>The compiler will type check it and do all the magic and then it transpiles the Typescript code to Javascript.
        And we have this:</p>
      <pre><code class="typescript language-typescript">const creditCard = {
    number: 2093,
    cardholder: 'TK',
    expirationDate: new Date(),
    secutiryCode: 101
};
</code></pre>
      <p>The same object, but now only with the value and without the type.</p>
      <h2 id="constraintstypenarrowing">Constraints &amp; Type Narrowing</h2>
      <blockquote>
        <p>When we restrict what we can do, it’s easier to understand what we can do.</p>
      </blockquote>
      <p>We use types as constraints to limit the bugs in your program. To understand this concept, I'm stealing an
        example from Lauren Tan's talk about Type Systems.</p>
      <pre><code class="typescript language-typescript">const half = x =&gt; x / 2;
</code></pre>
      <p>How many ways does this function can fail? Imagine a number of possible inputs:</p>
      <pre><code class="typescript language-typescript">[
  null,
  undefined,
  0,
  '0',
  'TK',
  { username: 'tk' },
  [42, 3.14],
  (a, b) =&gt; a + b,
]
</code></pre>
      <p>And what are the results for input:</p>
      <pre><code class="typescript language-typescript">half(null); // 0
half(undefined); // NaN
half(0); // 0
half('0'); // 0
half('TK'); // NaN
half({ username: 'tk' }); // NaN
half([42, 3.14]); // NaN
half((a, b) =&gt; a + b); // NaN
</code></pre>
      <p>We have different and unexpected results here. Here it's clear that we want a number as the <code>half</code>
        function, do the calculation, and great, it's done! But sometimes we don't control the input or the codebase is
        big, or new/unfamiliar, and we're able to make these little mistakes.</p>
      <p>The idea of adding constraints to our code is to narrow the possibilities of a range of types. In this case, we
        want to limit the input type to a <code>number</code> type. It's the only type that we care about to do the half
        calculation. With type narrowing, we again give type information to the compiler.</p>
      <pre><code class="typescript language-typescript">const half = (x: number) =&gt; x / 2;
</code></pre>
      <p>And with this new information, if we call the function with the test cases again, we have different results:
      </p>
      <pre><code class="typescript language-typescript">half(null); // Argument of type 'null' is not assignable to parameter of type 'number'.
half(undefined); // Argument of type 'undefined' is not assignable to parameter of type 'number'.(
half(0); // 0
half('0'); // Argument of type '"0"' is not assignable to parameter of type 'number'.
half('TK'); // Argument of type '"TK"' is not assignable to parameter of type 'number'.
half({ username: 'tk' }); // Argument of type '{ username: string; }' is not assignable to parameter of type 'number'.
half([42, 3.14]); // Argument of type 'number[]' is not assignable to parameter of type 'number'.
half((a, b) =&gt; a + b); // Argument of type '(a: any, b: any) =&gt; any' is not assignable to parameter of type 'number'.
</code></pre>
      <p>Basically the compiler will tell us that only the number type, in this case, the <code>0</code> value, is a
        valid input, it will compile, and allow to run the code. We narrow the input type and allow only the value we
        really want for this function.</p>
      <p>But are other ways to narrow the types in Typescript. Imagine we have a function that receives a parameter that
        can be either a string or a number.</p>
      <pre><code class="typescript language-typescript">type StringOrNumber = string | number;

function stringOrNumber(value: StringOrNumber) {}
</code></pre>
      <p>In the function body, the compiler won't know which methods or properties we can use for this type. Is it a
        string or number? We only know about the value in runtime. But we can narrow the type using the
        <code>typeof</code>:</p>
      <pre><code class="typescript language-typescript">function stringOrNumber(value: StringOrNumber) {
  if (typeof value === 'string') {
    // value.
    // your ide will show you the possible methods from the string type
    // (parameter) value: string
    value
  }

  if (typeof value === 'number') {
    // value.
    // your ide will show you the possible methods from the number type
    // (parameter) value: number
    value
  }
}
</code></pre>
      <p>With an <code>if</code> statement and the <code>typeof</code>, we can give more information to the compiler.
        Now it will know the specific type for each <code>if</code> body.</p>
      <p>The IDE knows what to show for the specific type. In runtime, when the value is a string, it will go to the
        first <code>if</code> statement, and the compiler will infer that the type is a string:
        <code>(parameter) value: string</code>.</p>
      <p>When the value is a number, it will go to the second <code>if</code> statement and the compiler will infer that
        a type is a number: <code>(parameter) value: number</code>.</p>
      <p>The <code>if</code> statement can be a helper to the compiler.</p>
      <p>Another example is when we have an optional property in an object, but in a function, we need to return a value
        based on this optional value.</p>
      <p>Imagine we have this type:</p>
      <pre><code class="typescript language-typescript">type User = {
  name: string;
  address: {
    street: string;
    complement?: string;
  }
};
</code></pre>
      <p>It's a simple <code>User</code> type. Let's focus on the <code>complement</code> property. It's optional (take
        a closer look at the <code>?</code> symbol), which means that it can be a <code>string</code> or
        <code>undefined</code>.</p>
      <p>Now we want to build a function to receive the user and get the length of the address complement. What about
        this?</p>
      <pre><code class="typescript language-typescript">function getComplementLength(user: User): number {
  return user.address.complement.length;
    // (property) complement?: string | undefined
  // Object is possibly 'undefined'.
}
</code></pre>
      <p>As we see earlier, the <code>complement</code> can be a <code>string</code> or <code>undefined</code>.
        <code>undefined</code> doesn't really have a property called <code>length</code>:</p>
      <pre><code class="typescript language-typescript">Uncaught TypeError: Cannot read property 'length' of undefined
</code></pre>
      <p>We could make something like:</p>
      <pre><code class="typescript language-typescript">function getComplementLength(user: User) {
  return user.address.complement?.length;
}
</code></pre>
      <p>If the <code>complement</code> has a string value, we can call <code>length</code>, otherwise, it will return
        <code>undefined</code>. So this function has two possible return types: <code>number | undefined</code>. But we
        want to ensure that we only return <code>number</code>. So we use a <code>if</code> or a ternary condition to
        narrow the type. It will only call <code>.length</code> when it has real value (or when it is not
        <code>undefined</code>).</p>
      <pre><code class="typescript language-typescript">function getComplementLength(user: User): number {
  return user.address.complement
    ? user.address.complement.length
    : 0;
}
</code></pre>
      <p>If it is <code>undefined</code>, we return the minimum length: <code>0</code>. Now we can use the function with
        the right type design with and without the complement. Without compile and runtime errors.</p>
      <pre><code class="typescript language-typescript">getComplementLength({
  name: 'TK',
  address: {
    street: 'Shinjuku Avenue'
  }
}); // 0

getComplementLength({
  name: 'TK',
  address: {
    street: 'Shinjuku Avenue',
    complement: 'A complement'
  }
}); // 12
</code></pre>
      <p>We'll get <code>0</code> from the first function call and <code>12</code> from the second call.</p>
      <p>With this <code>if</code> concept, we can also use other helpers to do the same thing. We could use the
        <code>in</code> operator to verify a property from an object, a <code>Array.isArray</code> to verify an array,
        or the <code>instanceof</code> for any other class type.</p>
      <p>We could also use more advanced concepts like assertion function or type guards, but I'll let these concepts to
        future posts.</p>
      <p>One thing that I want to dig deep in this <em>Constraints</em> topic is immutability.</p>
      <p>In Javascript and Typescript, we have the idea of mutable objects. If you define value in a variable, we can
        reassign it with another value later.</p>
      <pre><code class="typescript language-typescript">let email = 'harry.potter@mail.com';
email // 'harry.potter@mail.com'
email = 'hermione.granger@mail.com';
email // 'hermione.granger@mail.com'
</code></pre>
      <p>Now imagine you have a list of numbers. And you want to use a function to sum all of its numbers. The function
        looks like this:</p>
      <pre><code class="typescript language-typescript">function sumNumbers(numbers: number[]) {
  let sum = 0;
  let num = numbers.pop();

  while (num !== undefined) {
    sum += num;
    num = numbers.pop();
  }

  return sum;
}
</code></pre>
      <p>You call the function passing your list and get the result. It works just fine.</p>
      <pre><code class="typescript language-typescript">const list = [1, 2, 3, 4];
sumNumbers(list); // 10
</code></pre>
      <p>But what happened to your list? Did the function mutate it entirely?</p>
      <pre><code class="typescript language-typescript">list; // []
</code></pre>
      <p>If we use the list, it's empty now. The <code>pop</code> in the <code>sumNumbers</code> function is a "mutate"
        function. It gets the references and removes the item from them. It's not a copy, it's the real reference.</p>
      <p>In runtime, we can use other functions or ways to do the same thing: using reduce, do a for loop without the
        need to <code>pop</code> items from the array.</p>
      <p>But using Typescript, we can provide immutability in compile time. If you are not using types, it's possible to
        use a type assertion <code>as const</code>. Imagine this:</p>
      <pre><code class="typescript language-typescript">const author = {
  name: 'Walter Isaacson',
  email: 'walter.isaacson@mail.com',
  books: [
    {
      title: 'Leonardo Da Vinci',
      price: 50.00,
    }
  ]
};

author.books.push({
  title: 'Steve Jobs',
  price: 10.00
});
</code></pre>
      <p>Just an author object and then we add a new book to this author. The <code>push</code> method updates the
        book's array reference. It's a "mutate" method. Let's see if you use the const assertion <code>as const</code>:
      </p>
      <pre><code class="typescript language-typescript">const author = {
  name: 'Walter Isaacson',
  email: 'walter.isaacson@mail.com',
  books: [
    {
      title: 'Leonardo Da Vinci',
      price: 50.00,
    }
  ]
} as const;

author.books.push({
  title: 'Steve Jobs',
  price: 10.00
});
// Property 'push' does not exist on type
// 'readonly [{ readonly title: "Leonardo Da Vinci"; readonly price: 50; }]'
</code></pre>
      <p>The compiler won't compile. It gets an error on the author's object. It's is now readonly, and as a readonly
        object, it has no method called <code>push</code> (or any "mutate" method). We added a constraint to the
        author's object. Before it was a specific type (with all the "mutate" methods), and now we narrowed the type to
        be almost the same, but without the "mutate" methods. Type narrowing.</p>
      <p>To continue, let's add types to this object. The <code>book</code> and the <code>author</code>:</p>
      <pre><code class="typescript language-typescript">type Book = {
  title: string;
  price: number;
};

type Author = {
  name: string;
  email: string;
  books: Book[];
};
</code></pre>
      <p>Add the type to the author object:</p>
      <pre><code class="typescript language-typescript">const author: Author = {
  name: 'Walter Isaacson',
  email: 'walter.isaacson@mail.com',
  books: [
    {
      title: 'Leonardo Da Vinci',
      price: 50.00,
    }
  ]
};
</code></pre>
      <p>Add the type to a new book object:</p>
      <pre><code class="typescript language-typescript">const book: Book = {
  title: 'Steve Jobs',
  price: 30
};
</code></pre>
      <p>And now we can add the new book to the author:</p>
      <pre><code class="typescript language-typescript">author.name = 'TK';
author.books.push(book);
</code></pre>
      <p>It works just fine!</p>
      <p>I want to show another way to add immutability in compile time. Typescript has an utility type called
        <code>Readonly</code>.</p>
      <p>You can add the <code>readonly</code> for each property in an object. Something like this:</p>
      <pre><code class="typescript language-typescript">type Book = {
  readonly title: string;
  readonly price: number;
};
</code></pre>
      <p>But it can be very repetitive. So we can use the <code>Readonly</code> utility to add the <code>readonly</code>
        to all properties of an object:</p>
      <pre><code class="typescript language-typescript">type Book = Readonly&lt;{
  title: string;
  price: number;
}&gt;;
</code></pre>
      <p>One thing to keep in mind is that it doesn't add the readonly for nested properties. For example, if we add the
        <code>Readonly</code> to the <code>Author</code> type, it won't add the <code>readonly</code> to the
        <code>Book</code> type too.</p>
      <pre><code class="typescript language-typescript">type Author = Readonly&lt;{
  name: string;
  email: string;
  books: Book[];
}&gt;;
</code></pre>
      <p>All the properties from the author can't be reassigned, but you can mutate the <code>books</code> list here
        (<code>push</code>, <code>pop</code>, …) because the <code>Book[]</code> is not readonly. Let's see it.</p>
      <pre><code class="typescript language-typescript">const author: Author = {
  name: 'Walter Isaacson',
  email: 'walter.isaacson@mail.com',
  books: [
    {
      title: 'Leonardo Da Vinci',
      price: 50.00,
    }
  ]
};

const book: Book = {
  title: 'Steve Jobs',
  price: 30
};

author.books.push(book);
author.books;
/* =&gt;
 *
 * [
 *   {
 *     title: 'Leonardo Da Vinci',
 *     price: 50.00,
 *   },
 *   {
 *    title: 'Steve Jobs',
 *    price: 30
 *   }
 * ]
 *
 */
</code></pre>
      <p>The <code>push</code> will work just fine.</p>
      <p>So, how do we enforce a readonly to the <code>books</code>? We need to make sure that the array is a readonly
        type. We can use the <code>Readonly</code>, or use another utility from Typescript called
        <code>ReadonlyArray</code>. Let's see the two ways to do it.</p>
      <p>With <code>Readonly</code>:</p>
      <pre><code class="typescript language-typescript">type Author = Readonly&lt;{
  name: string;
  email: string;
  books: Readonly&lt;Book[]&gt;;
}&gt;;
</code></pre>
      <p>With <code>ReadonlyArray</code>:</p>
      <pre><code class="typescript language-typescript">type Author = Readonly&lt;{
  name: string;
  email: string;
  books: ReadonlyArray&lt;Book&gt;;
}&gt;;
</code></pre>
      <p>For me, both work great! But in my opinion, <code>ReadonlyArray</code> is more semantic and I also feel it is
        less verbose (not that the <code>Readonly</code> with an array is).</p>
      <p>What happened if we try to mutate the author object now?</p>
      <pre><code class="typescript language-typescript">author.name = 'TK'; // Cannot assign to 'name' because it is a read-only property.
author.books.push(book); // Property 'push' does not exist on type 'readonly [{ readonly title: "Leonardo Da Vinci"; readonly price: 50; }]'.
</code></pre>
      <p>Great! Now we can catch mutable operations in compile time. This is a way to use the concept of adding
        constraints to our types to make sure they only do what is really needed.</p>
      <h2 id="semanticsreadability">Semantics &amp; Readability</h2>
      <p>At first, I felt that Typescript could be very verbose because of the types and make the code much more complex
        than it should be. And it actually can. Strive for simplicity is the goal and it is difficult at the same time.
      </p>
      <p>This idea is very related to clean code and how we can write code to be human-readable and maintainable.
        Typescript is no different. Most of the cases, we don't need super complex types. Let the simple types do the
        work.</p>
      <p>Another thing that I find very useful is semantic of types.</p>
      <p>Imagine you need to add a string to the <code>sessionStorage</code> to save it in the browser. Your function
        looks like this:</p>
      <pre><code class="typescript language-typescript">function saveMyString(value: string): any {
  sessionStorage.myString = value;
}
</code></pre>
      <p>You add a type annotation to the string input and as you don't know about the returning type, you probably add
        a <code>any</code> type.</p>
      <p>But what's the real meaning behind this returning type? Is it returning anything?</p>
      <p>It just saves the string to the <code>sessionStorage</code>. It doesn't return anything. The <code>void</code>
        type was what you're looking for. As Typescript docs says: <code>the absence of having any type at all</code>.
      </p>
      <pre><code class="typescript language-typescript">function saveMyString(value: string): void {
  sessionStorage.myString = value;
}
</code></pre>
      <p>Great, the meaning of the type is correct now. The correctness is very important in a type system. It's a way
        to model our data, but also help maintain systems for future developers. Even if the developer is … you!</p>
      <p>Before we were talking about verbose code. And we can improve a lot of our code by using Typescript type
        inference.</p>
      <p>For some code, we don't need to explicitly add type annotation. The Typescript compiler will understand and
        infer it implicitly. For example:</p>
      <pre><code class="typescript language-typescript">const num: number = 1;
</code></pre>
      <p>This code is redundant. We can just let the compiler infers it like this:</p>
      <pre><code class="typescript language-typescript">const num = 1;
</code></pre>
      <p>In our example earlier, we add the annotation <code>void</code> to the <code>saveMyString</code> function. But
        as the function doesn't return any value, the compiler will infer that the returning type is <code>void</code>
        implicitly.</p>
      <p>When I learned this, I thought with myself. But one of the biggest advantages of using Typescript (or any other
        type system / static type language) is types as documentation. If we let the compiler infer most of the types,
        we won't have the documentation we want.</p>
      <p>But if you hover over the Typescript code in your editor (at least VS Code works like that), you can see the
        type information and relevant documentation.</p>
      <p>Let's see other examples of redundant code and make the code less verbose and let the compiler works for us.
      </p>
      <pre><code class="typescript language-typescript">function sum(a: number, b: number): number {
  return a + b;
};
</code></pre>
      <p>We don't need the returning type <code>number</code>, because the compiler knows that a <code>number</code> +
        another <code>number</code> is equal to a <code>number</code> type, and it is the returning type. It can be:</p>
      <pre><code class="typescript language-typescript">function sum(a: number, b: number) {
  return a + b;
};
</code></pre>
      <p>Implicit code, but with documentation, and the compiler does the work.</p>
      <p>Type inference works for methods too:</p>
      <pre><code class="typescript language-typescript">function squareAll(numbers: number[]): number[] {
  return numbers.map(number =&gt; number * number);
};
</code></pre>
      <p>This function gets a list of numbers and makes every number a squared value. The returning type is
        <code>number[]</code>, even though the result of a map is always a list, and as we have a list of numbers, it
        will always be a list of numbers. So we let the compiler infers this too:</p>
      <pre><code class="typescript language-typescript">function squareAll(numbers: number[]) {
  return numbers.map(number =&gt; number * number);
};
</code></pre>
      <p>This works the same way for objects too.</p>
      <pre><code class="typescript language-typescript">const person: { name: string, age: number } = {
  name: 'TK',
  age: 24
};
</code></pre>
      <p>A person object with a string name and a number age. But as we are assigning these values, the compiler can
        infer these types.</p>
      <pre><code class="typescript language-typescript">const person = {
  name: 'TK',
  age: 24
};
</code></pre>
      <p>If you hover the <code>person</code>, you get this:</p>
      <pre><code class="typescript language-typescript">const person: {
  name: string;
  age: number;
}
</code></pre>
      <p>The types are documented here.</p>
      <p>Another benefit of type inference is that we can easily refactor our code. It's a simple example, but good to
        illustrate the refactoring process. Let's get the <code>sum</code> function again.</p>
      <pre><code class="typescript language-typescript">function sum(a: number, b: number): number {
  return a + b;
};
</code></pre>
      <p>Instead of returning the sum number, we want to return <code>"Sum: {a + b}"</code>. So for <code>a = 1</code>
        and <code>b = 2</code>, we have the resulting string as <code>"Sum: 3"</code>.</p>
      <pre><code class="typescript language-typescript">function sum(a: number, b: number): string {
  return `Sum: ${a + b}`;
};

sum(1, 2); // Sum: 3
</code></pre>
      <p>Great! But now letting the compiler infers this.</p>
      <pre><code class="typescript language-typescript">// function sum(a: number, b: number): number
function sum(a: number, b: number) {
  return a + b;
};

// function sum(a: number, b: number): string
function sum(a: number, b: number) {
  return `Sum: ${a + b}`;
};
</code></pre>
      <p>We just need to modify the returning value and the type inference will work. No need to think about the
        returning type. This is a small example, but for more complex functions, it would work too.</p>
      <p>Back to the readability part, we can use <code>Enum</code>. A utility that defines a set of named constants.
        It's a way to give more meaning to the data in your application.</p>
      <p>In your node app or a frontend app, you possibly do some fetching to request data. You commonly use a fetch
        object to perform a request and sometimes you need to pass the accept headers.</p>
      <pre><code class="typescript language-typescript">fetch('/pokemons', {
  headers: {
    Accept: 'application/json'
  }
});

fetch('/harry-potter/spells', {
  headers: {
    Accept: 'application/json'
  }
});
</code></pre>
      <p>It's good, but we can also use an enum to separate this accept string in a constant and reuse.</p>
      <pre><code class="typescript language-typescript">enum MediaTypes {
  JSON = 'application/json'
}

fetch('/pokemons', {
  headers: {
    Accept: MediaTypes.JSON
  }
});

fetch('/harry-potter/spells', {
  headers: {
    Accept: MediaTypes.JSON
  }
});
</code></pre>
      <p>And we are able to add more data related to the <code>MediaTypes</code> like <code>PDF</code>:</p>
      <pre><code class="typescript language-typescript">enum MediaTypes {
  JSON = 'application/json',
  PDF = 'application/pdf'
}
</code></pre>
      <p>With <code>Enum</code>, we can encapsulate data into a meaningful block of code.</p>
      <p>Recently, I was implementing a "state" React component. It's basically a component that renders an empty state
        or an error state based on the request response.</p>
      <p>The UI for the empty and the error states were very similar. Only the title and the description text and the
        image icon were different. So I thought: "I have two ways in my mind to implement this: do the logic outside the
        component and pass all the information needed or pass a 'state type' and let the component render the correct
        icon and messages."</p>
      <p>So I built an enum:</p>
      <pre><code class="typescript language-typescript">export enum StateTypes {
  Empty = 'Empty',
  Error = 'Error'
};
</code></pre>
      <p>And I could just pass this data to the component as the <code>type</code>:</p>
      <pre><code class="typescript language-typescript">import ComponentState, { StateTypes } from './ComponentState';

&lt;ComponentState type={StateTypes.Empty} /&gt;
&lt;ComponentState type={StateTypes.Error} /&gt;
</code></pre>
      <p>In the component, it had a state object with all the information related to the <code>title</code>,
        <code>description</code>, and <code>icon</code>.</p>
      <pre><code class="typescript language-typescript">const stateInfo = {
  Empty: {
    title: messages.emptyTitle,
    description: messages.emptyDescription,
    icon: EmptyIcon,
  },
  Error: {
    title: messages.errorTitle,
    description: messages.errorDescription,
    icon: ErrorIcon,
  },
};
</code></pre>
      <p>So I could just receive the type based on the enum and use this <code>stateInfo</code> object with the
        <code>State</code> component from our design system:</p>
      <pre><code class="typescript language-typescript">export const ComponentState = ({ type }) =&gt; (
  &lt;State
    title={stateInfo[type].title}
    subtitle={stateInfo[type].subtitle}
    icon={stateInfo[type].icon}
  /&gt;
);
</code></pre>
      <p>This is a way to use an enum to encapsulate important data into a meaningful block of code in your application.
      </p>
      <p>Another cool feature from Typescript is optional properties. When we have properties from an object that can be
        a real value or undefined, we use an optional property to be explicitly that the property can be or not be
        there. The syntax for this is a simple <code>?</code> operator in the object property. Imagine this function:
      </p>
      <pre><code class="typescript language-typescript">function sumAll(a: number, b: number, c: number) {
  return a + b + c;
}
</code></pre>
      <p>But now the <code>c</code> value is optional:</p>
      <pre><code class="typescript language-typescript">function sumAll(a: number, b: number, c?: number) {
  return a + b + c;
}
</code></pre>
      <p>We add the <code>?</code> after <code>c</code>. But now we have a compiler error saying:</p>
      <pre><code class="typescript language-typescript">(parameter) c: number | undefined
Object is possibly 'undefined'.
</code></pre>
      <p>We can't sum an <code>undefined</code> value (well, actually in Javascript we can, but we receive a
        <code>NaN</code> value).</p>
      <p>We need to ensure that the <code>c</code> exists. Type narrowing!</p>
      <pre><code class="typescript language-typescript">function sumAll(a: number, b: number, c?: number) {
  if (c) {
    return a + b + c;
  }

  return a + b;
}
</code></pre>
      <p>If the <code>c</code> exists, it will be a <code>number</code> and we can sum all. If not, sum only the
        <code>a</code> and <code>b</code> values.</p>
      <p>An interesting part of this optional property is that it is a <code>undefined</code> not <code>null</code>.
        This is why we do this, we get a compile error:</p>
      <pre><code class="typescript language-typescript">let number = null;
sumAll(1, 2, number);
// Argument of type 'null' is not assignable to parameter of type 'number | undefined'.
</code></pre>
      <p>As the <code>?</code> operator doesn't handle the <code>null</code> value, choose to use the
        <code>undefined</code> type in your application and so you can still use the optional property and make the
        types consistent. We can use it like this:</p>
      <pre><code class="typescript language-typescript">let value: number | undefined;
sumAll(1, 2, value); // 3
</code></pre>
      <p>If you add a default value to the parameter, you won't need the <code>?</code> operator. Actually, the compiler
        will say that the <code>Parameter cannot have question mark and initializer</code>.</p>
      <pre><code class="typescript language-typescript">function sumAll(a: number, b: number, c: number = 3) {
  return a + b + c;
}
</code></pre>
      <p>Optional properties not only works on variables and parameters, but also in objects.</p>
      <p>An API response is a good example of type definition and optional property together. In API responses, data can
        be optional. Sometimes the API sends, sometimes it has no value.</p>
      <p>How we model our types is really important for an application. If an optional property is defined as a required
        type, we can make our application breaks in runtime. But if we design the types correctly, we have the possible
        errors in compile time.</p>
      <p>Imagine we are fetching a user data and this is the way we modeled the response type:</p>
      <pre><code class="typescript language-typescript">type UserResponse = {
  name: string;
  email: string;
  username: string;
  age: number;
  isActive: boolean;
};
</code></pre>
      <p>But in reality, the email is optional for the user. The API endpoint could return or not. But the
        <code>UserResponse</code> type we built treat it as a required property.</p>
      <p>After fetching the user data, we want to see if the user email matches with a specific domain.</p>
      <pre><code class="typescript language-typescript">function matchDomain(email: string) {
  return email.endsWith(domain);
}
</code></pre>
      <p>As the <code>email</code> property is required in the <code>UserResponse</code> type, the <code>email</code>
        parameter will also be required in the <code>matchDomain</code> function.</p>
      <p>This is the runtime we can get if the <code>email</code> is <code>undefined</code>:</p>
      <pre><code class="typescript language-typescript">// Uncaught TypeError: Cannot read property 'endsWith' of undefined
</code></pre>
      <p>But what would happen if we modeled the <code>UserResponse</code> correctly?</p>
      <pre><code class="typescript language-typescript">type UserResponse = {
  name: string;
  email?: string;
  username: string;
  age: number;
  isActive: boolean;
};
</code></pre>
      <p>Now the <code>email</code> is possibly <code>undefined</code> and it is explicit.</p>
      <p>But if we still keep the function <code>matchDomain</code> the same way, we get a compile error:</p>
      <pre><code class="typescript language-typescript">// Argument of type 'undefined' is not assignable to parameter of type 'string'.
</code></pre>
      <p>And this is great! Now we can fix the <code>email</code> parameter in this function using the <code>?</code>
        operator:</p>
      <pre><code class="typescript language-typescript">function matchDomain(email?: string) {
  return email.endsWith('email.com');
}
</code></pre>
      <p>But now we get a compile error when running <code>email.endsWith</code>, because it could be
        <code>undefined</code> too:</p>
      <pre><code class="typescript language-typescript">// (parameter) email: string | undefined
// Object is possibly 'undefined'.
</code></pre>
      <p>Type narrowing! We use an if block to return a <code>false</code> when the <code>email</code> is
        <code>undefined</code>. And run <code>endsWith</code> method only if the <code>email</code> is really a string:
      </p>
      <pre><code class="typescript language-typescript">function matchDomain(email?: string) {
  if (!email) return false;
  return email.endsWith('email.com');
}
</code></pre>
      <p>It's pretty nice when we can get runtime errors in compile time. Better to code than debugging after we ship in
        production, isn't it?</p>
      <h2 id="typecomposition">Type composition</h2>
      <p>Type composition is very useful when trying to reuse existing types for new places of the codebase. We don't
        need to rewrite new types, we can create a new type by composing existing ones.</p>
      <p>One example of composition I always have to handle using Redux or the <code>useReducer</code> hook from React
        is the idea of "reducers". A reducer can always receive a number of different actions.</p>
      <p>In this context, actions are objects with at least a <code>type</code> property. It looks like this:</p>
      <pre><code class="typescript language-typescript">enum ActionTypes {
  FETCH = 'FETCH'
}

type FetchAction = {
  type: typeof ActionTypes.FETCH;
};

const fetchAction: FetchAction = {
  type: ActionTypes.FETCH
};
</code></pre>
      <p>A <code>fetchAction</code> has a type <code>FetchAction</code> that has a property type that is a typeof
        <code>FETCH</code>.</p>
      <p>But a reducer can receive other actions too. For example a submit action:</p>
      <pre><code class="typescript language-typescript">enum ActionTypes {
  FETCH = 'FETCH',
  SUBMIT = 'SUBMIT'
}

type SubmitAction = {
  type: typeof ActionTypes.SUBMIT;
};

const submitAction: SubmitAction = {
  type: ActionTypes.SUBMIT
};
</code></pre>
      <p>For a specific container, we can compose all these actions into just one type and use it for the reducer
        parameter type.</p>
      <p>It would look like this:</p>
      <pre><code class="typescript language-typescript">type Actions = FetchAction | SubmitAction;

function reducer(state, action: Actions) {
  switch (action.type) {
    case ActionTypes.FETCH:
    // fetching action
    case ActionTypes.SUBMIT:
    // submiting action
  }
}
</code></pre>
      <p>All the possible actions are the <code>Actions</code> type. And we use a union type to "join" all action types.
        The action in the reducer can have the <code>FetchAction</code> or the <code>SubmitAction</code>.</p>
      <p>As a Potterhead, I couldn't miss a Harry Potter example. I want to build a simple function to choose a Hogwarts
        House based on the person trait. Let's start with the houses first.</p>
      <pre><code class="typescript language-typescript">type House = {
  name: string;
  traits: string[];
}

const gryffindor: House = {
  name: 'Gryffindor',
  traits: ['courage', 'bravery']
};

const slytherin: House = {
  name: 'Slytherin',
  traits: ['ambition', 'leadership']
};

const ravenclaw: House = {
  name: 'Ravenclaw',
  traits: ['intelligence', 'learning']
};

const hufflepuff: House = {
  name: 'Hufflepuff',
  traits: ['hard work', 'patience']
};

const houses: House[] = [
  gryffindor,
  slytherin,
  ravenclaw,
  hufflepuff
];
</code></pre>
      <p>I want to keep it simple, so the <code>House</code> type has only the <code>name</code> and the
        <code>traits</code>, a list of possible traits from people related to the house.</p>
      <p>And then, I create each house and added all of them to the <code>houses</code> list.</p>
      <p>Great! Now I'll build the <code>Person</code> type. A person can be a witch or a muggle.</p>
      <pre><code class="typescript language-typescript">type Witch = {
  name: string;
  trait: string;
    magicFamily: string;
}

type Muggle = {
  name: string;
    trait: string;
  email: string;
}
</code></pre>
      <p>And this is the part we combine these two different types using the union type:</p>
      <pre><code class="typescript language-typescript">type Person = Muggle | Witch;
</code></pre>
      <p>Using the intersection type, the <code>Person</code> type has all properties from <code>Muggle</code> or all
        from <code>Witch</code>.</p>
      <p>So now, if I create a <code>Muggle</code>, I need just the name, the trait, and the email:</p>
      <pre><code class="typescript language-typescript">const hermione: Muggle = {
  name: 'Hermione Granger',
    trait: 'bravery',
  email: 'hermione@mail.com'
};
</code></pre>
      <p>If I create a <code>Witch</code>, I need the name, the trait, and the magic family name:</p>
      <pre><code class="typescript language-typescript">const harry: Witch = {
  name: 'Harry Potter',
  trait: 'courage',
  magicFamily: 'Potter'
};
</code></pre>
      <p>And if I create a <code>Person</code>, I need at least the <code>name</code> and the <code>trait</code>
        properties from <code>Muggle</code> and <code>Witch</code>:</p>
      <pre><code class="typescript language-typescript">const tk: Person = {
  name: 'TK',
  email: 'tk@mail.com',
  trait: 'learning',
  magicFamily: 'Kinoshita'
};
</code></pre>
      <p>The <code>chooseHouse</code> is very simple. We just pas the houses and the person. Based on the person trait,
        the function will return the chosen house:</p>
      <pre><code class="typescript language-typescript">function chooseHouse(houses: House[], person: Person) {
  return houses.find((house) =&gt; house.traits.includes(person.trait))
}
</code></pre>
      <p>And applying all the people we created:</p>
      <pre><code class="typescript language-typescript">chooseHouse(houses, harry); // { name: 'Gryffindor', traits: ['courage', 'bravery'] }
chooseHouse(houses, hermione); // { name: 'Gryffindor', traits: ['courage', 'bravery'] }
chooseHouse(houses, tk); // { name: 'Ravenclaw', traits: ['intelligence', 'learning'] }
</code></pre>
      <p>Nice!</p>
      <p>The intersection type is a bit different, but it can also be used to combine existing types.</p>
      <p>When I was implementing a web app to <a href="https://github.com/leandrotk/ux-studies">apply my studies on
          UX</a>, I needed to create a prop type for the Image component.</p>
      <p>I had the type <code>ImageUrl</code> from the product type:</p>
      <pre><code class="typescript language-typescript">type ImageUrl = {
  imageUrl: string;
};
</code></pre>
      <p>And the <code>ImageAttr</code> to represent all the attributes for the image:</p>
      <pre><code class="typescript language-typescript">type ImageAttr = {
  imageAlt: string;
  width?: string
};
</code></pre>
      <p>But the props expected all this information in the component. Intersection type for the rescue!</p>
      <pre><code class="typescript language-typescript">type ImageProps = ImageUrl &amp; ImageAttr;
</code></pre>
      <p>Simple as that. So now, the component needs all these properties. The type looks like this:</p>
      <pre><code class="typescript language-typescript">type ImageProps = {
  imageUrl: string;
  imageAlt: string;
  width?: string
};
</code></pre>
      <p>And we can use this type this way:</p>
      <pre><code class="typescript language-typescript">const imageProps: ImageProps = {
  imageUrl: 'www.image.com',
  imageAlt: 'an image',
};

const imagePropsWithWidth: ImageProps = {
  imageUrl: 'www.image.com',
  imageAlt: 'an image',
  width: '100%'
};
</code></pre>
      <p>Nice! One more concept to reuse and compose types.</p>
      <p>I also find the <code>Pick</code> type very interesting and useful. We have other <a
          href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html">interesting
          types</a> that we could write here, but the idea here is to understand that we can compose type and there is
        no limit to reuse types. If you're interested in study other types, take a look at this post I wrote: <a
          href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html">Typescript
          Learnings: Interesting Types</a>.</p>
      <h2 id="tooling">Tooling</h2>
      <p>When you <code>npm install typescript</code>, you don't just get the compiler, you get the language service
        API, a standalone server called tsserver that editors can run to provide autocompletion, go-to, and other cool
        features.</p>
      <p>These features are what some people from the Typescript team call developer productivity tools like smart
        errors when type checking and IntelliSense (code completion, hover info, signature information). We look at
        these features throughout the whole article, but I want to make a special topic to talk about it.</p>
      <p>The Typescript type checker is powerful in the sense that it can infer types and provide information to some
        possible issues. Example: It inferred that the city is a string. And the <code>uppercase</code> is used the
        wrong way. As it knows it is a string, it also tries to find a possible method that the engineer is looking for.
      </p>
      <pre><code class="typescript language-typescript">const city = 'Tokyo';
city.toUppercase();
// Property 'toUppercase' does not exist on type
// 'string'. Did you mean 'toUpperCase'?
</code></pre>
      <p>In this case, the compiler is really smart, because it finds exatcly what we wanted.</p>
      <p>It also works for objects:</p>
      <pre><code class="typescript language-typescript">const people = [
  { name: 'TK', age: 24 },
  { name: 'Kaio', age: 12 },
  { name: 'Kazumi', age: 31 },
];

for (const person of people) {
  console.log(person.agi);
  // Property 'agi' does not exist on type '{ name: string; age: number; }'
}
</code></pre>
      <p>With the static types, the tooling can provide a great developer experience with code completion, hover info to
        show defined types, and signature information for methods and other data.</p>
      <p>If you type: <code>'TK'.</code>, the editor will show all the possible methods for the string object. The
        compiler knows it is a string. And it knows the methods from the <code>String</code> prototype. But it also
        provides the method signature. This is very interesting because we don't necessarily need to go to the docs. The
        "docs" is already in our code editor.</p>
      <p>It's an awesome experience while coding.</p>
      <p>The type definition "on hover" is another thing that we saw earlier in this article. Let the compiler infer the
        types implicitly and you won't lose the type documentation. Using the hover in the object, the IDE or editor
        will always be able to show the type definition.</p>
      <p>Another interesting thing is that Typescript will not only flag what could go wrong on runtime, but it also
        helps to find code that doesn't do what you intend.</p>
      <p>Imagine we have a function to open a snackbar if it is still closed. It would verify the status of the
        snackbar. If it is closed, just call another function to open it.</p>
      <pre><code class="typescript language-typescript">const buildSnackbar = (status: SnackbarStatus) =&gt; {
  if (status.isClosed) {
    openSnackbar();
  }
};
</code></pre>
      <p>And the type information for this snackbar is:</p>
      <pre><code class="typescript language-typescript">type SnackbarStatus = {
  isClosed: boolean;
};
</code></pre>
      <p>What happens if I call this function like this:</p>
      <pre><code class="typescript language-typescript">buildSnackbar({ isclosed: true });
</code></pre>
      <p>It won't break in runtime, because the <code>status</code> object has no <code>isClosed</code> attribute and
        the <code>undefined</code> object is a <code>falsy</code> value, so it will skip the if condition and not call
        the <code>openSnackbar</code> function. No runtime error. But probably it will behavior different than the
        expected.</p>
      <p>In Typescript, the compiler will give some hints to make it works properly. First it will show this error:</p>
      <pre><code class="typescript language-typescript">// Argument of type '{ isclosed: boolean; }' is not assignable to
// parameter of type 'SnackbarStatus'.
</code></pre>
      <p><code>isclosed</code> with downcased <code>C</code> is not assignable to the type. It's not defined there. This
        is the first hint to make you correct your code.</p>
      <p>The second is even better:</p>
      <pre><code class="typescript language-typescript">// Object literal may only specify known properties,
// but 'isclosed' does not exist in type 'SnackbarStatus'.
// Did you mean to write 'isClosed'?
</code></pre>
      <p>It tells exactly what you probably need to do: rename the <code>isclosed</code> to <code>isClosed</code>.</p>
      <p>We can talk a lot of things about the tooling about I think this is the main part.</p>
      <p>My suggestion to learn more about this is to just code in Typescript and "have a conversation" with the
        compiler. Read the errors. Play with the hover. See the autocompletion. Understand the method signatures. It's
        really a productive way to code.</p>
      <h2 id="tipslearnings">Tips &amp; Learnings</h2>
      <p>As the article is coming to an end, I want to just add the final thoughts, learnings, and tips to help you in
        your journey learning Typescript or just applying it in your projects.</p>
      <ul>
        <li>Really read the type error: this will help you better understand the issue and the types.</li>
        <li><code>strictNullChecks</code> and <code>noImplicitAny</code> can be very helpful in finding bugs. Enable
          this as soon as possible in your project. Use <code>strictNullChecks</code> to prevent “undefined is not an
          object”-style runtime errors. Use <code>noImplicitAny</code> to type the source code to give more type
          information for the compiler.</li>
        <li>Together with these compiler's configurations, I always recommend being very precise about your types.
          Mainly with the values that occur only in runtime like an API response. Correctness is important to catch as
          many bugs as possible in compile time.</li>
        <li>Understand the difference between runtime and compile time: types only affects in compile type. It runs the
          type checker and then compiles to Javascript. The Javascript source code doesn't use any type of references or
          type operations.</li>
        <li>Learn about utility types. We talk about more specific about the <code>Readonly</code> in the immutability
          in compile time, but Typescript has a box of helpers like <code>Required</code>, <code>Pick</code>, and many
          more.</li>
        <li>If possible, prefer letting the compiler infers the types for you. Most of the types and returning types are
          redundant. The Typescript compiler is very smart in this topic. If not possible, you can always add type
          annotations. And let the type assertions as to the last option.</li>
        <li>As writing code, take a look at the tooling. The design of the tooling provided in an IDE is amazing. The
          IntelliSense and type checking provide a really good experience.</li>
      </ul>
      <h1 id="resources">Resources</h1>
      <p>I compiled (pun very much intended!) a bunch of resources to help you learn more about programming languages,
        type systems, and the type mental model.</p>
      <p>Also, if you found the examples on this post useful, I added all of them this repository: <a
          href="https://github.com/leandrotk/thinking-in-types">Thinking in Types</a>. So you can fork and play with it.
      </p>
      <h3 id="typesystems">Type Systems</h3>
      <ul>
        <li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">Type Compatibility</a></li>
        <li><a
            href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4">Type
            Systems: Structural vs. Nominal typing explained</a></li>
        <li><a href="https://yakovfain.com/2018/07/11/learning-typescript-structural-vs-nominal-typing-system/">Learning
            TypeScript: Structural vs nominal typing systems</a></li>
        <li><a href="https://www.youtube.com/watch?v=GqmsQeSzMdw&feature=youtu.be">Constraints Liberate, Liberties
            Constrain — Runar Bjarnason</a></li>
        <li><a href="https://www.no.lol/2019-12-27-type-narrowing/">Type Narrowing in TypeScript</a></li>
        <li><a href="https://2ality.com/2020/06/type-guards-assertion-functions-typescript.html">TypeScript: narrowing
            types via type guards and assertion functions</a></li>
        <li><a
            href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html">Typescript
            Learnings: Interesting Types</a></li>
      </ul>
      <h3 id="toolingdeveloperexperience">Tooling &amp; Developer Experience</h3>
      <ul>
        <li><a href="https://www.youtube.com/watch?v=fnTEZk-oECM">Advanced TypeScript tooling at scale</a></li>
        <li><a href="https://www.youtube.com/watch?v=4C4wCGcsiT0">Type Systems & Props Design</a></li>
        <li><a href="https://www.youtube.com/watch?v=wSdV1M7n4gQ">Anders Hejlsberg on Modern Compiler Construction</a>
        </li>
        <li><a href="https://www.youtube.com/watch?v=f6TCB61fDwY">Typescript Compiler explained by the Author Anders
            Hejlsberg</a></li>
      </ul>
      <h3 id="compiletimevsruntime">Compile time vs Runtime</h3>
      <ul>
        <li><a href="https://stackoverflow.com/questions/846103/runtime-vs-compile-time">Compile time vs Runtime</a>
        </li>
        <li><a
            href="https://stackoverflow.com/questions/9471837/what-is-the-difference-between-run-time-error-and-compiler-error">Compile
            error vs Runtime error</a></li>
        <li><a href="https://stackoverflow.com/a/51132333/3159162">Value space and Type space</a></li>
        <li><a href="https://www.typescriptlang.org/play">A playground tool to play with Typescript and see the
            Javascript output</a></li>
      </ul>
      <h3 id="bestpractices">Best Practices</h3>
      <ul>
        <li><a href="https://engineering.zalando.com/posts/2019/02/typescript-best-practices.html">Typescript Best
            Practices</a></li>
        <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html">Do's and
            Don'ts for General Types</a></li>
      </ul>
      <h3 id="books">Books</h3>
      <ul>
        <li><a href="https://www.goodreads.com/book/show/48920810-programming-with-types">Programming with Types
            Book</a></li>
        <li><a href="https://www.goodreads.com/book/show/48570456-effective-typescript">Effective TypeScript: 62
            Specific Ways to Improve Your TypeScript Book</a></li>
        <li><a href="https://thinkingwithtypes.com/">Thinking with Types</a></li>
      </ul>
    </article>

    <iframe src="https://teekay.substack.com/embed" width="100%" height="300"
      style="border:1px solid #EEE; background:white;" frameborder="0" scrolling="no"></iframe>

    <div class="meta meta-footer">
      <div class="article-tag">
        Tags:
        <a class="tag-link" href="../../../tags/typescript.html">typescript</a>
        <a class="tag-link" href="../../../tags/javascript.html">javascript</a>
        <a class="tag-link" href="../../../tags/web_development.html">web_development</a>

      </div>
    </div>

    <div class="support-buttons">
      <a class="patreon-button" href="https://www.patreon.com/iamteekay" target="_blank" rel="noopener noreferrer">
        <img
          src="data:image/png;base64,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"
          height="50" width="50" alt="Patreon">
        Become a Patron
      </a>

      <a href="https://ko-fi.com/teekay" class="kofi-button" target="_blank" rel="noopener noreferrer">
        <img
          src="data:image/png;base64,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"
          class="coffee-icon" alt="Coffee icon">
        Buy me a coffee
      </a>
    </div>
  </div>

  <footer id="footer" class="article-footer">
    <div class="footer-left">
      Copyright &copy; 2020 TK
    </div>
    <div class="footer-right">
      <nav>
        <ul>
          <li><a href="../../../index.html">Home</a></li>
          <li><a href="../../../writing.html">Writing</a></li>
          <li><a href="https://github.com/leandrotk" target="_blank">Projects</a></li>
          <li><a href="../../../quotes.html">Quotes</a></li>
        </ul>
      </nav>
    </div>
  </footer>

  <script src="../../../javascripts/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>
